import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Object;
import java.util.stream.Collectors ;
import java.lang.Math.*;

parser code {:
    public enum operations{
        ADD,
        MUL,
        DIV,
        SUB,
        LESS,
        GRT,
        LSE,
        GRE,
        EQ
    };
    public class Scope{
        public HashMap<String,Value> variables;
        public HashMap<String,Value> constants;
        public Scope(){
            this.variables=new HashMap<String,Value>();
            this.constants=new HashMap<String,Value>();
        }
    }
    public class Tuple{
        public Value value;
        public String name;
        public Tuple(String name,Value value){
            this.name=name;
            this.value=value;
        }
    }
    public class Parameter{
        public boolean argLabel;
        public String name;
        public String label;
        public Value type;
        public boolean arrDim=false;
        public Parameter(Value type,String name){
            this.argLabel=false;
            this.name=name;
            this.type=type;
        }
        public Parameter(Value type,String name,String label){
            this.argLabel=true;
            this.name=name;
            this.type=type;
            this.label=label;
        }
        public void setArrayDim(){
            this.arrDim=true;
        }
    }
    public class Function{
        public String name;
        public String retType;
        public ArrayList<Parameter> pars;
        public StringBuffer functionOutput=new StringBuffer();
        public Scope scope;
        public int regId=0;
        public boolean returned;
        public int arrayNum=0;
        public Function(String name,String retType,ArrayList<Parameter> pars){
            this.name=name;
            this.retType=retType;
            this.pars=pars;
            this.returned=false;
        }
        public Function(String name){
            this.name=name;
        }
        public void setPars(ArrayList<Parameter> pars){
            this.pars=pars;
        }
        public void setRet(String retType){
            this.retType=retType;
        }
        public String irDec(){
            return retType+" ("+pars.stream().map(e->e.type.irDec()).collect(Collectors.joining(","))+") @"+name;
        }
    }
    public class Attribute{
        public String type;
        public int regId;
        public boolean immediate;
        public Object immediateValue;
        public boolean arrFunc=false;
        public boolean arrVar=false;
        public String associatedVarName;
        public ArrayList<String> dimensions;
        public ArrayList<Integer> dimensionsInt;
        public Attribute(String type){
            this.type=type;
            this.immediate=false;
        }
        public Attribute(String type,int regId){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
        }
        public Attribute(Object immediateValue,String type){
            this.immediate=true;
            this.immediateValue=immediateValue;
            this.type=type;
        }
        public Attribute(String type,int regId,String associatedVarName){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
            this.associatedVarName=associatedVarName;
        }
        public Attribute(String type,String associatedVarName,int regId,ArrayList<String> dimensions){
            this.type=type;
            this.arrFunc=true;
            this.arrVar=true;
            this.associatedVarName=associatedVarName;
            this.dimensions=dimensions;
            this.regId=regId;
        }
        public Attribute(String type,String associatedVarName,ArrayList<Integer> dimensionsInt,int regId){
            this.type=type;
            this.arrVar=true;
            this.associatedVarName=associatedVarName;
            this.dimensionsInt=dimensionsInt;
            this.regId=regId;
        }
        public void setReg(int regId){
            this.regId=regId;
        }
        public String getReg(){
            if(this.immediate) return this.immediateValue.toString();
            else    return "%"+this.regId;
        }
    }
    public class ArrayDec{
        public String type;
        public ArrayList<Attribute> value;
        public ArrayList<ArrayDec> arraysInside;
        public boolean closed;
        public boolean last;
        public boolean allImmediates;
        public ArrayDec(String type,ArrayList<Attribute> value,boolean closed,boolean allImmediates){
            this.type=type;
            this.value=value;
            this.closed=closed;
            this.last=true;
            this.allImmediates=allImmediates;
        }
        public ArrayDec(ArrayList<ArrayDec> arraysInside,String type,boolean closed,boolean allImmediates){
            this.type=type;
            this.arraysInside=arraysInside;
            this.closed=closed;
            this.last=false;
            this.allImmediates=allImmediates;
        }
        public void close(){
            this.type="["+arraysInside.size()+" x "+this.type+"]";
            this.closed=true;
        }
        public int level(){
            if(this.last) return 1;
            else return this.arraysInside.get(0).level();
        }
        public String printValue(){
            StringBuffer res=new StringBuffer();
            res.append("[");
            if(this.last){
                for(int i=0;i<value.size();i++){
                    res.append(value.get(i).immediateValue);
                    if(i!=value.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
            else{
                for(int i=0;i<arraysInside.size();i++){
                    res.append(arraysInside.get(i).printValue());
                    if(i!=arraysInside.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
        }
        public String getBaseType(){
            if(this.last) return this.value.get(0).type;
            else return this.arraysInside.get(0).getBaseType();
        }
        public ArrayList<Integer> getDimensions(){
            ArrayList<Integer> dims=new ArrayList<Integer>();
            if(this.last){
                dims.add(value.size());
                return dims;
            }
            else{
                dims.add(arraysInside.size());
                arraysInside.get(0).getDimensions().forEach(e->dims.add(e));
                return dims;
            }
        }
    }
    public class Value{
        public boolean integer=false;
        public boolean str=false;
        public boolean array=false;
        public boolean doub=false;
        public boolean classRef=false;
        public boolean funcPar=false;
        public boolean initialized;
        public boolean primitive;
        public boolean inoutPar=false;
        public int sizeInt=0;
        public int pointerAllocated=(-1);
        public boolean global=false;
        public String name;
        public ArrayList<String> dimensionsParameters=new ArrayList<String>();
        public ArrayList<Integer> dimensions=new ArrayList<Integer>();
        public Object immediateInitialization;
        //copy of already existing value
        public Value(Value o){
            this.integer=o.integer;
            this.str=o.str;
            this.doub=o.doub;
            this.array=o.array;
            this.classRef=o.classRef;
            this.sizeInt=o.sizeInt;
            this.funcPar=o.funcPar;
            this.initialized=o.initialized;
            this.primitive=o.primitive;
            this.inoutPar=o.inoutPar;
            this.dimensionsParameters=o.dimensionsParameters;
            this.dimensions=o.dimensions;
            this.immediateInitialization=o.immediateInitialization;
            this.pointerAllocated=o.pointerAllocated;
            this.global=o.global;
        }
        public Value(String type){
            if(type.equals("i32")){
                this.integer=true;
                this.sizeInt=32;
                this.primitive=true;
            }
            else if(type.equals("double")){
                this.doub=true;
                this.primitive=true;
            }
            else if(type.equals("i8*")){
                this.str=true;
                this.primitive=false;
            }
        }
        public Value(int intSize){
            this.integer=true;
            this.sizeInt=intSize;
            this.primitive=true;
        }
        public Value(boolean str){
            this.str=str;
            this.primitive=!str;
            this.doub=!str;
        }
        public void setImmediateInit(Object obj){
            this.initialized=true;
            this.immediateInitialization=obj;
        }
        public void setArrDimensions(ArrayList<Integer> arr){
            this.dimensions=arr;
        }
        public void setInout(boolean inout){
            this.funcPar=true;
            this.inoutPar=inout;
        }
        public void addArrLevel(){
            if(!this.array){
                this.array=true;
                this.dimensions=new ArrayList<Integer>();
                this.dimensions.add(10);
            }
            else this.dimensions.add(10);
        }
        public void addArrLevel(int i){
            if(!this.array){
                this.array=true;
                this.dimensions=new ArrayList<Integer>();
                this.dimensions.add(i);
            }
            else this.dimensions.add(i);
        }
        public void addFunctionDimension(String x){
            this.dimensionsParameters.add(x);
        }
        public boolean equal(Value o){
            return this.irDec().equals(o.irDec());
        }
        public String getBaseType(){
            if(this.str) return "i8*";
            else if(this.integer) return "i"+this.sizeInt;
            else if(this.doub) return "double";
            else return "ERROR";
        }
        public void setReg(int regId){
            if(this.pointerAllocated==-1) this.pointerAllocated=regId; 
        }
        public void setReg(String name){
            this.global=true;
            this.name=name;
        }
        public String getReg(){
            if(this.global) return "@"+this.name;
            else return "%"+this.pointerAllocated;
        }
        public String irDec(){
            if(this.array){
                if(this.funcPar)    return this.getBaseType()+"*";
                else{
                    StringBuffer res=new StringBuffer();
                    for(int i=0;i<this.dimensions.size();i++){
                        res.append("["+this.dimensions.get(i)+" x ");
                        if(i==this.dimensions.size()-1){
                            res.append(this.getBaseType());
                            for(int j=0;j<=i;j++) res.append("]");
                        }
                    }
                    return res.toString();
                }
            }
            else{
                if(this.funcPar && this.inoutPar && !this.str) return this.getBaseType()+"*";
                else return this.getBaseType();
            }
        }
        public boolean inoutNeedsDeref(){
            return this.funcPar && this.inoutPar && this.primitive;
        }

        @Override
        public String toString() {
            return this.irDec() +" with reg:"+this.getReg();
        }
    }
    public Scope globalScope=new Scope();
    public ArrayList<Scope> scopes=new ArrayList<Scope>();
    public StringBuffer outputBuffer=new StringBuffer();
    public StringBuffer errorBuffer=new StringBuffer();
    public StringBuffer globalBuffer=new StringBuffer();
    public int errors=0;
    public HashMap<String,Function> functions=new HashMap<String,Function>();
    public int regid=0;
    public int stringIndex=(-1);
    public boolean inFunction=false;
    public String functionName;
    public int currentIf=0;
    public int currentFor=0;
    public boolean inConditional=false;
    public ArrayList<String> callingFunction=new ArrayList<String>();
    public ArrayList<Integer> callingFunctionPar=new ArrayList<Integer>();
    public ArrayList<Integer> forloops=new ArrayList<Integer>();
    public void append(String x){
        if(inFunction)  functions.get(functionName).functionOutput.append(x);
        else    errorBuffer.append("\nCannot execute instructions outside of a function");
    }
    public int getId(){
        if(inFunction)  return ++functions.get(functionName).regId;
        else return -1;
    }
    public int getCurrentId(){
        if(inFunction)  return functions.get(functionName).regId;
        else return -1;
    }
    public String getIrOp(operations op,String type){
        boolean integer=type.equals("i32");
        System.out.println("Inside getirop with type: "+type+" and operator : "+op+", is it integer? "+integer);
        if(op==operations.ADD){
            if(integer) return "add nsw";
            else return "fadd nsw";
        }
        else if(op==operations.SUB){
            if(integer) return "sub";
            else return "fsub";
        }
        else if(op==operations.MUL){
            if(integer) return "mul";
            else return "fmul";
        }
        else if(op==operations.DIV){
            if(integer) return "sdiv";
            else return "fdiv";
        }
        else return "NOT SUPPORTED";
    }
    public String getVarIrDec(String var){
        System.out.println("Inside getvarirdec with: "+var+" and infunction? "+inFunction);
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)) return scope.variables.get(var).irDec();
            else if(scope.constants.containsKey(var)) return scope.constants.get(var).irDec();
        }
        return "ERROR";
    }
    public Value getValue(String var){
        System.out.println("Inside getvalueee with: "+var+" and infunction? "+inFunction);
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)){
                System.out.println("FOund the variale in the "+i+" scope as a var");
                return scope.variables.get(var);
            }
            else if(scope.constants.containsKey(var)){
                System.out.println("FOund the variale in the "+i+" scope as a let");
                return scope.constants.get(var);
            }
        }
        System.out.println("\tError couldn't find the variable "+var+", right now scope has size:"+scopes.size()+"and here are they now:");
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            System.out.println("vars:"+scope.variables);
            System.out.println("lets:"+scope.constants);
        }
        return null;
    }
    public String getRegVar(String var){
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)) return scope.variables.get(var).getReg();
            else if(scope.constants.containsKey(var)) return scope.constants.get(var).getReg();
        }
        System.out.println("\tError couldn't find the variable "+var+", right now scope has size:"+scopes.size()+"and here are they now:");
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            System.out.println("vars:"+scope.variables);
            System.out.println("lets:"+scope.constants);
        }
        return "ERROR";
    }
    public void storeRow(int i,ArrayDec a){
        Function f=functions.get(functionName);
        if(a.last){
            for(int j=0;j<a.value.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                f.functionOutput.append("\nstore "+a.value.get(j).type+" "+a.value.get(j).getReg()+","+a.value.get(j).type+"* %"+f.regId);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                storeRow(f.regId,a.arraysInside.get(j));
            }
        }
    }
    public String getCondIrOp(operations cond,boolean integer){
        if(cond==operations.LESS){
            if(integer) return "slt";
            else return "olt";
        }
        else if(cond==operations.GRT){
            if(integer) return "sgt";
            else return "ogt";
        }
        else if(cond==operations.LSE){
            if(integer) return "sle";
            else return "ole";
        }
        else if(cond==operations.GRE){
            if(integer) return "sge";
            else return "oge";
        }
        else if(cond==operations.EQ){
            if(integer) return "eq";
            else return "oeq";
        }
        else return "ERROR";
    }
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error, BUT BEFORE HERE WAS THE MAIN CONTENT: "+functions.get(functionName).functionOutput.toString()+"\n\n");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
:};

action code{:
    
:};

terminal LET,VAR,DOUBLEVAL,INTVAL;
terminal String ID,STRINGVAL,STRINGVALS,STRINGVALI,STRINGVALE;
terminal C,EQ,COL,BO,BC,GO,GC,ARROW;
terminal STRING,DOUBLE,INT,FUNC,USCORE;
terminal PLUS,MINUS,DIV,MUL;
terminal LESS,GREATER,LESSEQ,GREATEREQ,AND,OR,EQUAL,NOT;
terminal ELIF,ELSE,IF,FOR,IN,WHILE,DOT;
terminal QO,QC,INOUT;
terminal PRINT,RETURN;
terminal BREAK,CONTINUE,DEREF;
terminal uminus;

non terminal PROG,DEC;
non terminal HashMap<String,Value> IDINITlist;
non terminal Tuple INIT;
non terminal ASS,STMS,STM,FUNCTION,FSTMTS,FSTM,CONDSTM,CONDSTMS;
non terminal WHILECOND,FORCOND;
non terminal ArrayList<String> IDlist;
non terminal Value TYPE;
non terminal Attribute VAL;
non terminal Value TList,T;
non terminal operations OP;
non terminal Attribute ATTR,EXP,PROC;
non terminal Parameter PAR;
non terminal ArrayList<Parameter> PARlist;
non terminal Attribute CPAR;
non terminal ArrayList<Attribute> CPARlist,CPAREList;
non terminal String RETVAL;
non terminal Value FTYPE;
non terminal Boolean INOUTF;
non terminal Attribute STR;
non terminal Integer STRINGVALINTERP;
non terminal Function FUNCDef;
non terminal ArrayList<Integer> PRINTPARList;
non terminal Attribute  IDARR;
non terminal ArrayDec ARRVALE,ARRVAL;
non terminal ArrayList<Attribute> EXPL;
non terminal Integer IFCONDDEC;
non terminal Attribute IFCC,IFCOND;
non terminal IFCOMPLETEBLOCK;
non terminal Attribute CONDATTR,COND;
non terminal operations CONDOP;
non terminal Integer WHILEDEF;
non terminal RET;

precedence left PLUS,MINUS,OR;
precedence left MUL,DIV,AND;
precedence left uminus;

start with PROG;

PROG::= {:scopes.add(globalScope);:} STMS {:
    if(errors==0)   System.out.println(globalBuffer+"\n"+outputBuffer+"\n");
    else System.out.println("There were "+errors+"errors, here there are:\n"+ errorBuffer);
:} ;

//declarations of variables

DEC::= LET IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        if(t.initialized){
            if(t.array){
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                if(dec.allImmediates) globalBuffer.append("\n@"+a+" = global "+dec.type+" "+dec.printValue());
                else errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                if(att.immediate)   globalBuffer.append("\n@"+a+"= global "+t.irDec()+" "+att.getReg()+",align 4");
                else{
                    errorBuffer.append("\ncannot declare and initialize a global variable with a dynamic value");
                    errors++;
                }
            }
        }
        else globalBuffer.append("\n@"+a+" = global "+t.irDec()+" zeroinitializer");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
    else{
        int id=getId();
        append("\n%"+id+"= alloca "+t.irDec()+",align 4");
        if(t.initialized){
            if(t.array){
                int i=getCurrentId();
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                storeRow(i,dec);
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
            }
        }
        Value v=new Value(t);
        v.setReg(id);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
});:} | VAR IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        if(t.initialized){
            if(t.array){
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                if(dec.allImmediates) globalBuffer.append("\n@"+a+" = global "+dec.type+" "+dec.printValue());
                else errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                globalBuffer.append("\n@"+a+"= global "+t.irDec()+" "+att.getReg()+",align 4");
            }
        }
        else globalBuffer.append("\n@"+a+" = global "+t.irDec()+" zeroinitializer");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
    else{
        int id=getId();
        append("\n%"+id+"= alloca "+t.irDec()+",align 4");
        if(t.initialized){
            if(t.array){
                int i=getCurrentId();
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                storeRow(i,dec);
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
            }
        }
        Value v=new Value(t);
        v.setReg(id);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
});:} | LET IDINITlist:l {:
    scopes.get(scopes.size()-1).constants.putAll(l);
:} | VAR IDINITlist:l {:
    scopes.get(scopes.size()-1).variables.putAll(l);
:};

IDlist::= IDlist:l C ID:x {: ArrayList<String> arr= new ArrayList<String>(l);
                            arr.add(x);
                            RESULT=arr;:}| ID:x{:ArrayList<String> arr= new ArrayList<String>();
                            arr.add(x);
                            RESULT=arr;:};

IDINITlist::= IDINITlist:l C INIT:i {:
    if(i!=null) l.put(i.name,i.value);
    RESULT=l;
:} | INIT:i {:
    HashMap<String,Value> res=new HashMap<String,Value>();
    if(i!=null) res.put(i.name,i.value);
    RESULT=res;
:};

INIT::= ID:i EQ VAL:l {:
    if(inFunction){
        int id=getId();
        append("\n%"+id+"= alloca "+l.type+",align 4");
        append("\nstore "+l.type+" "+l.getReg()+","+l.type+"* %"+id);
        Value v=new Value(l.type);
        v.setImmediateInit(l);
        v.setReg(id);
        RESULT=new Tuple(i,v);
    }
    else{
        if(l.immediate){
            globalBuffer.append("\n@"+i+" = global "+l.type+" "+l.getReg());
            Value v=new Value(l.type);
            v.setImmediateInit(l);
            v.setReg(i);
            RESULT=new Tuple(i,v);
        }
        else{
            errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
            errors++;
            RESULT=null;
        }
    }
:} | ID:i EQ ARRVALE:l {:
    if(inFunction){
        int id=getId();
        append("\n%"+id+"= alloca "+l.type+",align 4");
        storeRow(id,l);
        Value v=new Value(l.getBaseType());
        ArrayList<Integer> dimensions=l.getDimensions();
        dimensions.forEach(e->v.addArrLevel(e));
        v.setImmediateInit(l);
        v.setReg(id);
        RESULT=new Tuple(i,v);
    }
    else{
        if(l.allImmediates){
            globalBuffer.append("\n@"+i+" = global "+l.type+" "+l.printValue());
            Value v=new Value(l.getBaseType());
            ArrayList<Integer> dimensions=l.getDimensions();
            dimensions.forEach(e->v.addArrLevel(e));
            v.setImmediateInit(l);
            v.setReg(i);
            RESULT=new Tuple(i,v);
        }
        else{
            errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
            errors++;
            RESULT=null;
        }
    }
:} ;

TYPE::= COL TList:t {:RESULT=t;:}| COL TList:t EQ VAL:v {:
    t.setImmediateInit(v);
    RESULT=t;
:} | COL TList:t EQ ARRVALE:l {:
    t.setArrDimensions(l.getDimensions());
    t.setImmediateInit(l);
    RESULT=t;
:};

VAL::= DOUBLEVAL:v {:RESULT=new Attribute(v,"double");:}| INTVAL:v {:RESULT=new Attribute(v,"i32");:}| STR:v {:RESULT=v;:};

STR::= STRINGVAL:s {:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    int id;
    if(inFunction){
        append("\n%"+getId()+" = getelementptr inbounds ["+s.length()+" x i8], ["+s.length()+" x i8]* @.str."+stringIndex+" , i32 0, i32 0");
        RESULT=new Attribute("i8*",getCurrentId());
    }
    else    RESULT=new Attribute("getelementptr inbounds (["+s.length()+" x i8], ["+s.length()+" x i8]* @.str."+stringIndex+" , i32 0, i32 0)","["+(s.length()+1)+" x i8]");
:}| STRINGVALS:s STRINGVALINTERP:i STRINGVALE:e{:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(e.length()+1)+" x i8] c\""+e+"\\00\"");
    int stringArrPointer;
    int stringGepPointer;
    append("\n%"+getId()+" = alloca [200 x i8], align 1");
    stringArrPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [200 x i8], [200 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
    stringGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+(stringIndex-1)+", i32 0, i32 0))");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* %"+i+")");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(e.length()+1)+" x i8], ["+(e.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0))");
    RESULT=new Attribute("i8*",stringGepPointer);
:};

STRINGVALINTERP::= STRINGVALINTERP:i STRINGVALI:s EXP:e {:
    int expPointer,expGep,finalArrPointer,finalGepPointer;
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    append("\n%"+getId()+" = alloca [200 x i8], align 1");
    finalArrPointer=getCurrentId();
    append("\n%"+getId()+" = alloca [20 x i8], align 1");
    expPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+expPointer+" , i32 0, i32 0");
    expGep=getCurrentId();
    append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+expGep+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
    append("\n%"+getId()+" = getelementptr inbounds [200 x i8],[200 x i8]* %"+finalArrPointer+",i32 0,i32 0");
    finalGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+finalGepPointer+",i8* %"+i+")");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+finalGepPointer+",i8* getelementptr inbounds (["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+stringIndex+",i32 0,i32 0))");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+finalGepPointer+",i8* %"+expGep+")");
    RESULT=finalGepPointer;
:}| EXP:e {:
    int stringArrPointer;
    int stringGepPointer;
    append("\n%"+getId()+" = alloca [20 x i8], align 1");
    stringArrPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
    stringGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
    RESULT=stringGepPointer;
:};


ARRVALE::= QO ARRVALE:l QC {:
    l.close();
    RESULT=l;
:}| ARRVALE:l C ARRVAL:a {:
    if(l.closed && a.closed){
        ArrayList<ArrayDec> arr=new ArrayList<ArrayDec>();
        arr.add(l);
        arr.add(a);
        RESULT=new ArrayDec(arr,a.type,false,a.allImmediates&&l.allImmediates);
    }
    else{
        l.arraysInside.add(a);
        l.allImmediates=a.allImmediates&&l.allImmediates;
        RESULT=l;
    }
:}| ARRVAL:a {:RESULT=a;:};

ARRVAL::= QO EXPL:l QC {:
    boolean allImmediates=true;
    for(int i=0;i<l.size();i++){
        if(!l.get(i).immediate){
            allImmediates=false;
            break;
        }
    }
    RESULT=new ArrayDec("["+l.size()+" x "+l.get(0).type+"]",l,true,allImmediates);
:};

EXPL::= EXPL:l C EXP:e {:
    if(l.get(l.size()-1).type.equals(e.type)) l.add(e);
    else{
        errors++;
        errorBuffer.append("\nCannot have heterogenous arrays");
    }
    RESULT=l;
:} | EXP:e {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    l.add(e);
    RESULT=l;
:} | ;

TList::= QO TList:t QC {:
    t.addArrLevel();
    RESULT=t;
:}| T:t {:RESULT=t;:};

T::=STRING {:RESULT=new Value(true);:}| DOUBLE {:RESULT=new Value(false);:}| INT{:RESULT=new Value(32);:} ;

//assignment

ASS::= ID:a EQ EXP:e {:
    Value v=getValue(a);
    if(a==null || e==null)  return null;
    String type=v.irDec();
    if(!e.type.equals(type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
    }
    //System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
    else    append("\nstore "+type+" "+e.getReg()+","+type+"* "+getRegVar(a));
:} | IDARR:a EQ EXP:e {:
    if(a==null || e==null)  return null;
    if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
    }
    else    append("\nstore "+e.type+" "+e.getReg()+","+a.type+"* "+a.getReg());
:} | ID:a OP:op EQ EXP:e {:
    Value v=getValue(a);
    if(a==null || e==null)  return null;
    String type=v.irDec();
    if(!e.type.equals(type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
    }
    //System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
    else{
        if(type.equals("i8*")){
            if(op==operations.ADD){
                append("\n%"+getId()+"= alloca [200 x i8]");
                int newArr=getCurrentId();
                append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+newArr+",i32 0, i32 0");
                int idPointer=getCurrentId();
                append("\n%"+getId()+"= load i8*,i8** "+v.getReg());
                int idA=getCurrentId();
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idPointer+",i8* %"+idA+")");
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+idPointer+",i8* "+e.getReg()+")");
                append("\nstore i8* %"+idPointer+",i8** "+v.getReg());
            }
            else errorBuffer.append("\nonly operation allowed on string is the add");
        }
        else{
            //String type=getVarIrDec(a);
            int id;
            append("\n%"+getId()+"= load "+type+","+type+"* "+v.getReg());
            id=getCurrentId();
            append("\n%"+getId()+" = "+getIrOp(op,e.type)+" "+e.type+" %"+id+","+e.getReg());
            append("\nstore "+e.type+" %"+getCurrentId()+","+e.type+"* "+v.getReg());
        }
    }
:};

CPAR::= ID:name COL EXP:e {:
    Parameter p=functions.get(callingFunction.get(callingFunction.size()-1)).pars.get(callingFunctionPar.size()-1);
    if(p.argLabel){
        if(!p.label.equals(name)){
            errorBuffer.append("\nExpected "+p.label+" as the label for the parameter instead received "+name);
            errors++;
        }
    }
    else{
        errorBuffer.append("\nDidn't expect a label for the parameter instead received "+name);
        errors++;
    }
    if(!p.type.irDec().equals(e.type)){
        errorBuffer.append("\nType mismatch in parameter passing");
        errors++;
    }
    RESULT=e;
:} | EXP:e {:
    Parameter p=functions.get(callingFunction.get(callingFunction.size()-1)).pars.get(callingFunctionPar.size()-1);
    if(p.argLabel){
        errorBuffer.append("\nExpected "+p.label+" as the label for the parameter instead the label is missing");
        errors++;
    }
    if(!p.type.irDec().equals(e.type)){
        errorBuffer.append("Type mismatch in parameter passing");
        errors++;
    }
    RESULT=e;
:} | ID:i {:
    Value v=getValue(i);
    if(v.array){
        if(v.funcPar){
            append("\n%"+getId()+" = load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
            RESULT=new Attribute(v.getBaseType(),i,getCurrentId(),v.dimensionsParameters);
        }
        else{
            String type=v.irDec();
            int lastId=-1;
            ArrayList<Integer> subdim=new ArrayList<Integer>();
            for(int j=0;j<v.dimensions.size();j++){
                String newType,subir;
                if(j>0){
                    append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* %"+lastId+",i32 0,i32 0");
                    subir=type.substring(1,type.length()-1);
                    if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                    else newType=subir.substring(subir.indexOf("["),subir.length());
                    type=newType;
                    lastId=getCurrentId();
                }
                else{
                    append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* "+v.getReg()+",i32 0,i32 0");
                    subir=type.substring(1,type.length()-1);
                    if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                    else newType=subir.substring(subir.indexOf("["),subir.length());
                    type=newType;
                    lastId=getCurrentId();
                    subdim.add(v.dimensions.get(j));
                }
            }
            if(subdim.size()>0) RESULT=new Attribute(type,i,subdim,lastId);
            else RESULT=new Attribute(type,lastId,i);
        }
    }
    else if(v.str){
        append("\n%"+getId()+"= getelementptr "+v.irDec()+","+v.irDec()+"* "+v.getReg()+",i32 0,i32 0");
        RESULT=new Attribute(v.irDec(),getCurrentId(),i);
    }
    else{
        append("\n%"+getId()+"= load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
        RESULT=new Attribute(v.irDec(),getCurrentId(),i);
    }
:} | ID:name COL ID:i {:
    Value v=getValue(i);
    if(v.array){
        if(v.funcPar){
            append("\n%"+getId()+" = load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
            RESULT=new Attribute(v.getBaseType(),i,getCurrentId(),v.dimensionsParameters);
        }
        else{
            String type=v.irDec();
            int lastId=-1;
            ArrayList<Integer> subdim=new ArrayList<Integer>();
            for(int j=0;j<v.dimensions.size();j++){
                String newType,subir;
                if(j>0){
                    append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* %"+lastId+",i32 0,i32 0");
                    subir=type.substring(1,type.length()-1);
                    if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                    else newType=subir.substring(subir.indexOf("["),subir.length());
                    type=newType;
                    lastId=getCurrentId();
                }
                else{
                    append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* "+v.getReg()+",i32 0,i32 0");
                    subir=type.substring(1,type.length()-1);
                    if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                    else newType=subir.substring(subir.indexOf("["),subir.length());
                    type=newType;
                    lastId=getCurrentId();
                    subdim.add(v.dimensions.get(j));
                }
            }
            if(subdim.size()>0) RESULT=new Attribute(type,i,subdim,lastId);
            else RESULT=new Attribute(type,lastId,i);
        }
    }
    else if(v.str){
        append("\n%"+getId()+"= getelementptr "+v.irDec()+","+v.irDec()+"* "+v.getReg()+",i32 0,i32 0");
        RESULT=new Attribute(v.irDec(),getCurrentId(),i);
    }
    else{
        append("\n%"+getId()+"= load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
        RESULT=new Attribute(v.irDec(),getCurrentId(),i);
    }
:} | IDARR:i | ID:name COL IDARR:i | DEREF IDARR:i | DEREF ID:i | ID:name COL DEREF IDARR:i | ID:name COL DEREF ID:i ;

EXP::= EXP:e PLUS EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32") && !e.type.equals("i8*")){
        errorBuffer.append("\nCan do substractions only on integeres,strings and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.type.equals("i8*")){
            append("\n%"+getId()+"= alloca [200 x i8]");
            int newArr=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+newArr+",i32 0, i32 0");
            id=getCurrentId();
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+id+",i8* "+e.getReg()+")");
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+id+",i8* "+a.getReg()+")");
            RESULT=new Attribute("i8*",id);
        }
        else{
            if(e.immediate){
                if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
                else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
            }
            else{
                if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
                else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
            }
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:}| ATTR:a {:
    RESULT=a;
:}| EXP:e MINUS EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32")){
        errorBuffer.append("\nCan do substractions only on integeres and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.immediate){
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
        }
        else{
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:} | EXP:e MUL EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32")){
        errorBuffer.append("\nCan do multiplications only on integeres and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.immediate){
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
        }
        else{
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:} | EXP:e DIV EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32")){
        errorBuffer.append("\nCan do divisions only on integeres and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.immediate){
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
        }
        else{
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:} | BO EXP:e BC {:RESULT=e;:}
| MINUS EXP:e {:
    append("\n%"+getId()+" = sub "+e.type+" 0,"+e.getReg());
    RESULT=new Attribute(e.type,getCurrentId());
:} %prec uminus;


ATTR::= PROC:p {:
    RESULT=p;
:} | ID:i {:
    Value v=getValue(i);
    if(v!=null){   
        String type=v.irDec();
        String reg=v.getReg();
        int id;
        append("\n%"+getId()+"= load "+type+","+type+"* "+reg);
        id=getCurrentId();
        RESULT=new Attribute(type,id,i);
    }
    else RESULT=null;
:} | VAL:v {:
    RESULT=v;
:} | IDARR:i {:
    int id;
    append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+i.getReg());
    id=getCurrentId();
    RESULT=new Attribute(i.type,id);
:} ;

IDARR::= IDARR:i QO EXP:a QC {:
    if(i.arrFunc){
        if(i.dimensions.size()>1){
            ArrayList<String> s=new ArrayList<String>();
            for(int j=0;j<i.dimensions.size();j++){
                if(j==0)    append("\n%"+getId()+"= mul i32 %"+i.dimensions.get(j)+","+a.getReg());
                else{
                    int oldId=getCurrentId();
                    append("\n%"+getId()+"= mul i32 %"+oldId+",%"+i.dimensions.get(j));
                    s.add(i.dimensions.get(j));
                }
            }
            int lastId=getCurrentId();
            append("\n%"+getId()+"= add nsw i32 %"+lastId+","+i.getReg());
            RESULT=new Attribute(i.type,i.associatedVarName,getCurrentId(),s);
        }
        else{
            append("\n%"+getId()+"= add nsw i32 "+a.getReg()+","+i.getReg());
            int lastId=getCurrentId();
            Value v=getValue(i.associatedVarName);
            String baseType=v.getBaseType();
            append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+v.getReg());
            int loadId=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+i.type+" %"+loadId+", i32 %"+lastId);
            RESULT=new Attribute(baseType,getCurrentId(),i.associatedVarName);
        }
    }
    else{
        String ir=i.type;
        append("\n%"+getId()+" = getelementptr inbounds "+i.type+","+i.type+"* "+i.getReg()+", i32 0, i32 "+a.getReg());
        String subir=ir.substring(1,ir.length()-1);
        String newType;
        if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
        else newType=subir.substring(subir.indexOf("["),subir.length());
        RESULT=new Attribute(newType,getCurrentId(),i.associatedVarName);
    }
:} | ID:i QO EXP:a QC {:
    Value v=getValue(i);
    if(v.funcPar && v.dimensions.size()>1){
        System.out.println("Entered the if");
        System.out.println("THere are "+v.dimensions+" AND "+v.dimensionsParameters);
        ArrayList<String> s=new ArrayList<String>();
        for(int j=0;j<v.dimensionsParameters.size();j++){
            if(j==0)    append("\n%"+getId()+"= mul i32 %"+v.dimensionsParameters.get(j)+","+a.getReg());
            else{
                int oldId=getCurrentId();
                append("\n%"+getId()+"= mul i32 %"+oldId+",%"+v.dimensionsParameters.get(j));
                s.add(v.dimensionsParameters.get(j));
            }
        }
        System.out.println("JUst finished the first loop, now dimensions are "+s);
        RESULT=new Attribute(v.irDec(),i,getCurrentId(),s);
    }
    else if(v.funcPar && v.dimensions.size()==1){
        String baseType=v.getBaseType();
        append("\n%"+getId()+"= load "+baseType+"*,"+baseType+"** "+v.getReg());
        int loadId=getCurrentId();
        append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+baseType+"* %"+loadId+", i32 "+a.getReg());
        RESULT=new Attribute(baseType,getCurrentId(),i);
    }
    else{
        String ir=getVarIrDec(i);
        String reg=getRegVar(i);
        append("\n%"+getId()+" = getelementptr inbounds "+ir+","+ir+"* "+reg+", i32 0, i32 "+a.getReg());
        String subir=ir.substring(1,ir.length()-1);
        String newType;
        if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
        else newType=subir.substring(subir.indexOf("["),subir.length());
        RESULT=new Attribute(newType,getCurrentId(),i);
    }
:} ;

OP::= PLUS {:RESULT=operations.ADD;:} | MINUS {:RESULT=operations.SUB;:} | MUL {:RESULT=operations.MUL;:} | DIV {:RESULT=operations.DIV;:} ;

//statements

STMS::= STMS STM | STM;

STM::=DEC | FUNCTION;

CONDSTMS::= CONDSTMS CONDSTM | ;

CONDSTM::= ASS | PROC | DEC | BREAK {:
    if(inConditional){
        append("\nbr label %for.exit."+forloops.get(forloops.size()-1));
        getId();
    }
    else {
        errorBuffer.append("Used continue statement while not in a for loop or while loop");
    }
:} | CONTINUE {:
    if(inConditional){
        append("\nbr label %for.inc."+forloops.get(forloops.size()-1));
        getId();
    }
    else {
        errorBuffer.append("Used continue statement while not in a for loop or while loop");
    }
:};

PROC::= ID:name {:
    callingFunction.add(name);
    callingFunctionPar.add(0);
:} BO CPAREList:l BC {:
    Function f=functions.get(name);
    int id=0;
    if(f.retType.equals("void"))    append("\ncall "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
    else{
        append("\n%"+(getId())+"=call "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
        id=getCurrentId();
    }
    callingFunctionPar.remove(callingFunctionPar.size()-1);
    callingFunction.remove(callingFunction.size()-1);
    RESULT=new Attribute(f.retType,id);
:} | PRINT BO PRINTPARList:l BC{:
        l.forEach(p->append("\n%"+getId()+" = call i32 (i8*, ...) @printf(i8* %"+p+")"));
        append("\n%"+getId()+" = call i32 (i8*, ...) @printf(i8* getelementptr inbounds([2 x i8], [2 x i8]* @.str.newline, i32 0, i32 0))");
:} ;

PRINTPARList::= PRINTPARList:l C STR:s {:
    l.add(s.regId);
    RESULT=l;
:}| STR:s{:
    ArrayList<Integer> pointers=new ArrayList<Integer>();
    pointers.add(s.regId);
    RESULT=pointers;
:};

CPAREList::= CPARlist:l {:RESULT=l;:} | {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    System.out.println("REduced EMPTY in cparElist");
    RESULT=l;
:};

CPARlist::= CPARlist:l C CPAR:p {:
    System.out.println("REduced cparlist c cpar in cparlist");
    l.add(p);
    if(p.arrVar){
        if(p.arrFunc){
            for(int i=0;i<p.dimensions.size();i++){
                append("\n%"+getId()+"= load i32,i32* "+p.dimensions.get(i));
                l.add(new Attribute("i32",getCurrentId()));
            }
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensions.size());
        }
        else{
            for(int i=0;i<p.dimensionsInt.size();i++)  l.add(new Attribute(p.dimensionsInt.get(i),"i32"));
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensionsInt.size());
        }
    }
    RESULT=l;
:} | CPAR:p{:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    System.out.println("REduced cpar in cparlist");
    l.add(p);
    if(p.arrVar){
        if(p.arrFunc){
            for(int i=0;i<p.dimensions.size();i++){
                append("\n%"+getId()+"= load i32,i32* "+p.dimensions.get(i));
                l.add(new Attribute("i32",getCurrentId()));
            }
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensions.size());
        }
        else{
            for(int i=0;i<p.dimensionsInt.size();i++)  l.add(new Attribute(p.dimensionsInt.get(i),"i32"));
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensionsInt.size());
        }
    }
    RESULT=l;
:};


//control loop blocks

IFCOMPLETEBLOCK::= IFCC:ifc {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    append("\nbr label %if.exit."+ifc.type+".0");
    append("\nif.exit."+ifc.type+".0:");
:} | IFCC:ifc ELSE {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO CONDSTMS GC {:
    append("\nbr label %if.exit."+ifc.type+".0");
    append("\nif.exit."+ifc.type+".0:");
    scopes.remove(scopes.size()-1);
:};

IFCC::= IFCC:ifc ELIF {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
:} COND:cond {:
    append("\nbr i1 "+cond.getReg()+", label %if.body."+ifc.type+"."+ifc.regId+", label %if.elif."+ifc.type+"."+(ifc.regId+1));
    append("\nif.body."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO CONDSTMS GC {:
    append("\nbr label %if.exit."+ifc.type+".0");
    ifc.setReg(ifc.regId+1);
    scopes.remove(scopes.size()-1);
    RESULT=ifc;
:} | IFCOND:ifc {:RESULT=ifc;:};

IFCOND::= IFCONDDEC:ifNum GO CONDSTMS GC {:
    append("\nbr label %if.exit."+ifNum+".0");
    scopes.remove(scopes.size()-1);
    RESULT=new Attribute(""+ifNum,0);
:} | IFCONDDEC STM ;

IFCONDDEC::= IF COND:cond {:
    int currIf=currentIf++;
    append("\nbr i1 "+cond.getReg()+", label %if.body."+currIf+", label %if.elif."+currIf+".0");
    append("\nif.body."+currIf+":");
    scopes.add(new Scope());
    RESULT=currIf;
:};


WHILECOND::= WHILEDEF:wh COND:cond {:
    append("\nbr i1 "+cond.getReg()+", label %for.body."+wh+", label %for.exit."+wh);
    append("\nfor.body."+wh+":");
    scopes.add(new Scope());
    if(!inConditional)  inConditional=true;
    forloops.add(wh);
:} GO CONDSTMS GC {:
    append("\nbr label %for.inc."+wh);
    append("\nfor.inc."+wh+":");
    append("\n%"+getId()+" = add nsw i32 0,0");
    append("\nbr label %for.cond."+wh);
    append("\nfor.exit."+wh+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:};

WHILEDEF::= WHILE {:
    int currWh=currentFor++;
    append("\nbr label %for.cond."+currWh);
    append("\nfor.cond."+currWh+":");
    RESULT=currWh;
:};

FORCOND::= FOR ID:index IN INTVAL:start DOT DOT DOT INTVAL:finish {:
    System.out.println("BEfore this for the size of the scope array was : " +scopes.size());
    scopes.add(new Scope());
    System.out.println("AFter it's "+scopes.size());
    int currFor=currentFor++;
    append("\nbr label %for.init."+currFor);
    append("\nfor.init."+currFor+":");
    append("\n%"+getId()+" = alloca i32, align 4");
    int indexId=getCurrentId();
    Value v=new Value(32);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    append("\nstore i32 "+start+",i32* %"+indexId);
    append("\nbr label %for.cond."+currFor);
    append("\nfor.cond."+currFor+":");
    append("\n%"+getId()+" = load i32,i32* %"+indexId);
    int idload=getCurrentId();
    append("\n%"+getId()+" = icmp sle i32 %"+idload+","+finish);
    append("\nbr i1 %"+getCurrentId()+", label %for.body."+currFor+", label %for.exit."+currFor);
    append("\nfor.body."+currFor+":");
    if(!inConditional)  inConditional=true;
    forloops.add(currFor);
    RESULT=currFor;
:} GO CONDSTMS GC {:
    System.out.println("FInished the for loop, now scopes has size "+scopes.size());
    append("\nbr label %for.inc."+RESULT);
    append("\nfor.inc."+RESULT+":");
    append("\n%"+getId()+" = load i32,i32* "+getRegVar(index));
    int k=getCurrentId();
    append("\n%"+getId()+" = add nsw i32 %"+k+",1");
    append("\nstore i32 %"+getCurrentId()+",i32* "+getRegVar(index));
    append("\nbr label %for.cond."+RESULT);
    append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:} | FOR ID IN INTVAL DOT DOT LESS INTVAL GO CONDSTMS GC | FOR ID IN ID DOT DOT DOT ID GO CONDSTMS GC | FOR ID IN ID DOT DOT LESS ID GO CONDSTMS GC | 
FOR ID IN ID DOT DOT DOT INTVAL GO CONDSTMS GC | FOR ID IN ID DOT DOT LESS INTVAL GO CONDSTMS GC | FOR ID IN INTVAL DOT DOT DOT ID GO CONDSTMS GC | FOR ID IN INTVAL DOT DOT LESS ID GO CONDSTMS GC | FOR ID IN STRINGVAL GO CONDSTMS GC;


COND::= COND:a AND COND:b {:
    append("\n%"+getId()+" = and i1 "+a.getReg()+","+b.getReg());
    int andreg=getCurrentId();
    append("\n%"+getId()+"=  icmp eq i1 %"+andreg+",1");
    a.setReg(getCurrentId());
    RESULT=a;
:}| COND:a OR COND:b {:
    append("\n%"+getId()+" = or i1 "+a.getReg()+","+b.getReg());
    int andreg=getCurrentId();
    append("\n%"+getId()+"= icmp eq i1 %"+andreg+",1");
    a.setReg(getCurrentId());
    RESULT=a;
:}| NOT COND:a {:
    append("\n%"+getId()+"= icmp eq i1 "+a.getReg()+",0");
    a.setReg(getCurrentId());
    RESULT=a;
:} | CONDATTR:a {:
    if(!a.type.equals("i1")){
        if(a.type.equals("double"))  append("\n%"+getId()+"= fcmp ne "+a.type+" "+a.getReg()+",0");
        else    append("\n%"+getId()+"= icmp ne "+a.type+" "+a.getReg()+",0");
        RESULT=new Attribute("i1",getCurrentId());
    }
    else    RESULT=a;
:} | BO COND:a BC {: RESULT=a;
:};

CONDATTR::= EXP:a CONDOP:cond EXP:b {:
    if(!b.type.equals("double"))  append("\n%"+getId()+"= icmp "+getCondIrOp(cond,true)+" "+a.type+" "+a.getReg()+","+b.getReg());
    else append("\n%"+getId()+"= fcmp "+getCondIrOp(cond,false)+" "+a.type+" "+a.getReg()+","+b.getReg());
    RESULT=new Attribute("i1",getCurrentId());
:}| EXP:a {:RESULT=a;:};

CONDOP::= LESS {:RESULT=operations.LESS;:} | GREATER {:RESULT=operations.GRT;:} | LESSEQ {:RESULT=operations.LSE;:} | GREATEREQ {:RESULT=operations.GRE;:} | EQUAL {:RESULT=operations.EQ;:};

//function declaration

FUNCTION::=FUNCDef:f GO FSTMTS GC {:
    if(!f.returned){
        if(f.retType.equals("void"))    f.functionOutput.append("\nret void");
        else    System.out.println("Didn't have a return statement and function isn't of type void");
    }
    outputBuffer.append("{"+f.functionOutput+"\n}");
    inFunction=false;
    functionName=null;
    scopes.remove(scopes.size()-1);
:};

FUNCDef::=FUNC ID:name {:
    inFunction=true;
    functionName=name;
    System.out.println("Function "+name+" found!");
    Function f=new Function(name);
    functions.put(name,f);
:} BO PARlist:l BC RETVAL:r{:
    Function f=functions.get(name);
    outputBuffer.append("\ndefine "+r+" @"+name+" ("+l.stream().map(e->e.type.irDec()+" %"+e.name).collect(Collectors.joining(","))+")");
    f.setPars(l);
    f.setRet(r);
    f.scope=new Scope();
    scopes.add(f.scope);
    l.stream().filter(e->!e.arrDim).forEach(e->{
        System.out.println("Starting parameter "+e.name);
        if(!e.type.inoutNeedsDeref()){
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec());
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.functionOutput.append("\nstore "+e.type.irDec()+" %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            if(e.type.inoutPar) f.scope.variables.put(e.name,v);
            else    f.scope.constants.put(e.name,v);
        }
        else{
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec()+"*");
            int reg=f.regId;
            f.functionOutput.append("\nstore "+e.type.irDec()+"* %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            f.functionOutput.append("\n%"+(++f.regId)+" = load "+e.type.irDec()+"*,"+e.type.irDec()+"** %"+f.regId);
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.scope.variables.put(e.name,v);
        }
        System.out.println("JUst finished parameter "+e.name+", now output is:\n"+f.functionOutput);
    });
    RESULT=f;
:};

RETVAL::=ARROW T:t {:RESULT=t.irDec();:}| {:RESULT="void";:};

PARlist::= PARlist:l C PAR:p {:
    l.add(p);
    if(p.type.array){
        int dim=p.type.dimensions.size();
        for(int i=0;i<dim-1;i++){
            Value x=new Value(32);
            x.setInout(false);
            Parameter pfor=new Parameter(x,"dim."+functions.get(functionName).arrayNum+"."+i);
            pfor.setArrayDim();
            l.add(pfor);
            p.type.addFunctionDimension("dim."+functions.get(functionName).arrayNum+"."+i);
            System.out.println("NOw dimensions parameters are: "+p.type.dimensionsParameters);
        }
        if(dim>1) functions.get(functionName).arrayNum++;
    }
    RESULT=l;
:}| PAR:p {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    l.add(p);
    if(p.type.array){
        int dim=p.type.dimensions.size();
        System.out.println("Parameter "+p.name+" has "+dim+" dimensions and function has array num:"+ functions.get(functionName).arrayNum);
        for(int i=0;i<dim-1;i++){
            Value x=new Value(32);
            x.setInout(false);
            Parameter pfor=new Parameter(x,"dim."+functions.get(functionName).arrayNum+"."+i);
            pfor.setArrayDim();
            l.add(pfor);
            p.type.addFunctionDimension("dim."+functions.get(functionName).arrayNum+"."+i);
            System.out.println("NOw dimensions parameters are: "+p.type.dimensionsParameters);
        }
        if(dim>1) functions.get(functionName).arrayNum++;
    }
    RESULT=l;
:} | {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    RESULT=l;
:};

PAR::= ID:label ID:name FTYPE:f {:RESULT=new Parameter(f,name,label);:}| ID:name FTYPE:f {:RESULT=new Parameter(f,name,name);:}| USCORE ID:name FTYPE:f{:RESULT=new Parameter(f,name);:};
 
FTYPE::= COL INOUTF:i TList:t {:t.setInout(i);RESULT=t;:};

INOUTF::=INOUT {:RESULT=true;:} | {:RESULT=false;:};

FSTMTS::= FSTMTS FSTM | ;

FSTM::=IFCOMPLETEBLOCK | WHILECOND | FORCOND | ASS | PROC | DEC | RET ;

RET::= RETURN EXP:e {:
    Function f=functions.get(functionName);
    if(f.retType.equals(e.type)){
        f.functionOutput.append("\nret "+e.type+" "+e.getReg());
        f.returned=true;
        getId();
    }
    else System.out.println("Returning a type that doesn't match with the return type of the function");
:} | RETURN {:
    Function f=functions.get(functionName);
    if(!f.retType.equals("void")) System.out.println("REturning nothing from a non void function");
    else{
        f.functionOutput.append("\nret void");
        f.returned=true;
        getId();
    }
:};