import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Object;
import java.util.stream.Collectors ;
import java.lang.Math.*;

parser code {:
    public enum operations{
        ADD,
        MUL,
        DIV,
        SUB,
        LESS,
        GRT,
        LSE,
        GRE,
        EQ
    };
    public class Scope{
        public HashMap<String,Value> variables;
        public HashMap<String,Value> constants;
        public Scope(){
            this.variables=new HashMap<String,Value>();
            this.constants=new HashMap<String,Value>();
        }
    }
    public class Tuple{
        public Value value;
        public String name;
        public Tuple(String name,Value value){
            this.name=name;
            this.value=value;
        }
    }
    public class Parameter{
        public boolean argLabel;
        public String name;
        public String label;
        public Value type;
        public boolean arrDim=false;
        public Parameter(Value type,String name){
            this.argLabel=false;
            this.name=name;
            this.type=type;
        }
        public Parameter(Value type,String name,String label){
            this.argLabel=true;
            this.name=name;
            this.type=type;
            this.label=label;
        }
        public void setArrayDim(){
            this.arrDim=true;
        }
    }
    public class Function{
        public String name;
        public String retType;
        public ArrayList<Parameter> pars;
        public StringBuffer functionOutput=new StringBuffer();
        public Scope scope;
        public int regId=0;
        public boolean returned;
        public int arrayNum=0;
        public Function(String name,String retType,ArrayList<Parameter> pars){
            this.name=name;
            this.retType=retType;
            this.pars=pars;
            this.returned=false;
        }
        public Function(String name){
            this.name=name;
        }
        public void setPars(ArrayList<Parameter> pars){
            this.pars=pars;
        }
        public void setRet(String retType){
            this.retType=retType;
        }
        public String irDec(){
            return retType+" ("+pars.stream().map(e->e.type.irDec()).collect(Collectors.joining(","))+") @"+name;
        }
    }
    public class Attribute{
        public String type;
        public int regId;
        public boolean immediate;
        public Object immediateValue;
        public boolean arrFunc=false;
        public boolean arrVar=false;
        public String associatedVarName;
        public ArrayList<String> dimensions;
        public ArrayList<Integer> dimensionsInt;
        public boolean variable=false;
        public String getRegVariable;
        public Attribute(String type){
            this.type=type;
            this.immediate=false;
        }
        public Attribute(String type,int regId){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
        }
        public Attribute(Object immediateValue,String type){
            this.immediate=true;
            this.immediateValue=immediateValue;
            this.type=type;
        }
        public Attribute(String type,int regId,String associatedVarName){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
            this.associatedVarName=associatedVarName;
        }
        public Attribute(String type,String associatedVarName,int regId,ArrayList<String> dimensions){
            this.type=type;
            this.arrFunc=true;
            this.arrVar=true;
            this.associatedVarName=associatedVarName;
            this.dimensions=dimensions;
            this.regId=regId;
        }
        public Attribute(String type,String associatedVarName,ArrayList<Integer> dimensionsInt,int regId){
            this.type=type;
            this.arrVar=true;
            this.associatedVarName=associatedVarName;
            this.dimensionsInt=dimensionsInt;
            this.regId=regId;
        }
        public Attribute(String type,String getReg,String associatedVarName){
            this.type=type;
            this.getRegVariable=getReg;
            this.variable=true;
            this.associatedVarName=associatedVarName;
        }
        public void setReg(int regId){
            this.regId=regId;
        }
        public String getReg(){
            if(this.variable)   return this.getRegVariable;
            if(this.immediate) return this.immediateValue.toString();
            else    return "%"+this.regId;
        }
    }
    public class ArrayDec{
        public String type;
        public ArrayList<Attribute> value;
        public ArrayList<ArrayDec> arraysInside;
        public boolean closed;
        public boolean last;
        public boolean allImmediates;
        public ArrayDec(String type,ArrayList<Attribute> value,boolean closed,boolean allImmediates){
            this.type=type;
            this.value=value;
            this.closed=closed;
            this.last=true;
            this.allImmediates=allImmediates;
        }
        public ArrayDec(ArrayList<ArrayDec> arraysInside,String type,boolean closed,boolean allImmediates){
            this.type=type;
            this.arraysInside=arraysInside;
            this.closed=closed;
            this.last=false;
            this.allImmediates=allImmediates;
        }
        public void close(){
            this.type="["+arraysInside.size()+" x "+this.type+"]";
            this.closed=true;
        }
        public int level(){
            if(this.last) return 1;
            else return this.arraysInside.get(0).level();
        }
        public String printValue(){
            StringBuffer res=new StringBuffer();
            res.append("[");
            if(this.last){
                for(int i=0;i<value.size();i++){
                    res.append(value.get(i).immediateValue);
                    if(i!=value.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
            else{
                for(int i=0;i<arraysInside.size();i++){
                    res.append(arraysInside.get(i).printValue());
                    if(i!=arraysInside.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
        }
        public String getBaseType(){
            if(this.last) return this.value.get(0).type;
            else return this.arraysInside.get(0).getBaseType();
        }
        public ArrayList<Integer> getDimensions(){
            ArrayList<Integer> dims=new ArrayList<Integer>();
            if(this.last){
                dims.add(value.size());
                return dims;
            }
            else{
                dims.add(arraysInside.size());
                arraysInside.get(0).getDimensions().forEach(e->dims.add(e));
                return dims;
            }
        }
    }
    public class Value{
        public boolean integer=false;
        public boolean str=false;
        public boolean array=false;
        public boolean doub=false;
        public boolean classRef=false;
        public boolean funcPar=false;
        public boolean initialized;
        public boolean primitive;
        public boolean inoutPar=false;
        public int sizeInt=0;
        public int pointerAllocated=(-1);
        public boolean global=false;
        public String name;
        public ArrayList<String> dimensionsParameters=new ArrayList<String>();
        public ArrayList<Integer> dimensions=new ArrayList<Integer>();
        public Object immediateInitialization;
        //copy of already existing value
        public Value(Value o){
            this.integer=o.integer;
            this.str=o.str;
            this.doub=o.doub;
            this.array=o.array;
            this.classRef=o.classRef;
            this.sizeInt=o.sizeInt;
            this.funcPar=o.funcPar;
            this.initialized=o.initialized;
            this.primitive=o.primitive;
            this.inoutPar=o.inoutPar;
            this.dimensionsParameters=o.dimensionsParameters;
            this.dimensions=o.dimensions;
            this.immediateInitialization=o.immediateInitialization;
            this.pointerAllocated=o.pointerAllocated;
            this.global=o.global;
        }
        public Value(String type){
            if(type.equals("i32")){
                this.integer=true;
                this.sizeInt=32;
                this.primitive=true;
            }
            else if(type.equals("double")){
                this.doub=true;
                this.primitive=true;
            }
            else if(type.equals("i8*")){
                this.str=true;
                this.primitive=false;
            }
        }
        public Value(int intSize){
            this.integer=true;
            this.sizeInt=intSize;
            this.primitive=true;
        }
        public Value(boolean str){
            this.str=str;
            this.primitive=!str;
            this.doub=!str;
        }
        public void setImmediateInit(Object obj){
            this.initialized=true;
            this.immediateInitialization=obj;
        }
        public void setArrDimensions(ArrayList<Integer> arr){
            this.dimensions=arr;
        }
        public void setInout(boolean inout){
            this.funcPar=true;
            this.inoutPar=inout;
        }
        public void addArrLevel(){
            if(!this.array){
                this.array=true;
                this.dimensions=new ArrayList<Integer>();
                this.dimensions.add(10);
            }
            else this.dimensions.add(10);
        }
        public void addArrLevel(int i){
            if(!this.array){
                this.array=true;
                this.dimensions=new ArrayList<Integer>();
                this.dimensions.add(i);
            }
            else this.dimensions.add(i);
        }
        public void addFunctionDimension(String x){
            this.dimensionsParameters.add(x);
        }
        public boolean equal(Value o){
            return this.irDec().equals(o.irDec());
        }
        public String getBaseType(){
            if(this.str) return "i8*";
            else if(this.integer) return "i"+this.sizeInt;
            else if(this.doub) return "double";
            else return "ERROR";
        }
        public void setReg(int regId){
            if(this.pointerAllocated==-1) this.pointerAllocated=regId; 
        }
        public void setReg(String name){
            this.global=true;
            this.name=name;
        }
        public String getReg(){
            if(this.global) return "@"+this.name;
            else return "%"+this.pointerAllocated;
        }
        public String irDec(){
            if(this.array){
                if(this.funcPar)    return this.getBaseType()+"*";
                else{
                    StringBuffer res=new StringBuffer();
                    for(int i=0;i<this.dimensions.size();i++){
                        res.append("["+this.dimensions.get(i)+" x ");
                        if(i==this.dimensions.size()-1){
                            res.append(this.getBaseType());
                            for(int j=0;j<=i;j++) res.append("]");
                        }
                    }
                    return res.toString();
                }
            }
            else{
                if(this.funcPar && this.inoutPar && !this.str) return this.getBaseType()+"*";
                else return this.getBaseType();
            }
        }
        public boolean inoutNeedsDeref(){
            return this.funcPar && this.inoutPar && this.primitive && !this.array;
        }

        @Override
        public String toString() {
            return this.irDec() +" with reg:"+this.getReg();
        }
    }
    public Scope globalScope=new Scope();
    public ArrayList<Scope> scopes=new ArrayList<Scope>();
    public StringBuffer outputBuffer=new StringBuffer();
    public StringBuffer errorBuffer=new StringBuffer();
    public StringBuffer globalBuffer=new StringBuffer();
    public StringBuffer globalInitializations=new StringBuffer();
    public int globalInitializationsId=0;
    public int errors=0;
    public HashMap<String,Function> functions=new HashMap<String,Function>();
    public int regid=0;
    public int stringIndex=(-1);
    public boolean inFunction=false;
    public String functionName;
    public int currentIf=0;
    public int currentFor=0;
    public boolean inConditional=false;
    public ArrayList<String> callingFunction=new ArrayList<String>();
    public ArrayList<Integer> callingFunctionPar=new ArrayList<Integer>();
    public ArrayList<Integer> forloops=new ArrayList<Integer>();
    public void append(String x){
        if(inFunction)  functions.get(functionName).functionOutput.append(x);
        else{
            errorBuffer.append("\nCannot execute instructions outside of a function");
            errors++;
        }
    }
    public int getId(){
        if(inFunction)  return ++functions.get(functionName).regId;
        else{
            errors++;
            return -1;
        }
    }
    public int getCurrentId(){
        if(inFunction)  return functions.get(functionName).regId;
        else{
            errors++;
            return -1;
        }
    }
    public String getIrOp(operations op,String type){
        boolean integer=type.equals("i32");
        if(op==operations.ADD){
            if(integer) return "add nsw";
            else return "fadd nsw";
        }
        else if(op==operations.SUB){
            if(integer) return "sub";
            else return "fsub";
        }
        else if(op==operations.MUL){
            if(integer) return "mul";
            else return "fmul";
        }
        else if(op==operations.DIV){
            if(integer) return "sdiv";
            else return "fdiv";
        }
        else return "NOT SUPPORTED";
    }
    public Tuple getValue(String var){
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var))    return new Tuple("var",scope.variables.get(var));
            else if(scope.constants.containsKey(var))   return new Tuple("let",scope.constants.get(var));
        }
        errorBuffer.append("\nCouldn't find value "+var);
        errors++;
        return null;
    }
    public void storeRow(int i,ArrayDec a){
        Function f=functions.get(functionName);
        if(a.last){
            for(int j=0;j<a.value.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                if(a.value.get(j).type.equals("i8*")){
                    int id=f.regId;
                    f.functionOutput.append("\n%"+(++f.regId)+" = alloca [200 x i8]");
                    int idStr=f.regId;
                    f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds [200 x i8],[200 x i8]* %"+idStr+",i32 0,i32 0");
                    int strPoint=f.regId;
                    f.functionOutput.append("\n%"+(++f.regId)+" = call i8* (i8*,i8*) @strcpy(i8* %"+strPoint+",i8* "+a.value.get(j).getReg()+")");
                    f.functionOutput.append("\nstore i8* %"+strPoint+",i8** %"+id);
                }
                else    f.functionOutput.append("\nstore "+a.value.get(j).type+" "+a.value.get(j).getReg()+","+a.value.get(j).type+"* %"+f.regId);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                storeRow(f.regId,a.arraysInside.get(j));
            }
        }
    }
    public void storeGlobalRowStringsR(int i,ArrayDec a){
        if(a.last){
            Random rand=new Random();
            for(int j=0;j<a.value.size();j++){
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                int id=globalInitializationsId;
                String idStr="support"+globalInitializationsId+"rand"+rand.nextInt(999);
                globalBuffer.append("\n@"+idStr+" = global [200 x i8] zeroinitializer");
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds [200 x i8],[200 x i8]* @"+idStr+",i32 0,i32 0");
                int strPoint=globalInitializationsId;
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = call i8* (i8*,i8*) @strcpy(i8* %"+strPoint+",i8* %"+a.value.get(j).regId+")");
                globalInitializations.append("\nstore i8* %"+strPoint+",i8** %"+id);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                storeGlobalRowStringsR(globalInitializationsId,a.arraysInside.get(j));
            }
        }
    }
    public void storeGlobalRowStrings(String i,ArrayDec a){
        if(a.last){
            Random rand=new Random();
            for(int j=0;j<a.value.size();j++){
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds "+a.type+","+a.type+"* @"+i+",i32 0,i32 "+j);
                int id=globalInitializationsId;
                String idStr="support"+globalInitializationsId+"rand"+rand.nextInt(999);
                globalBuffer.append("\n@"+idStr+" = global [200 x i8] zeroinitializer");
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds [200 x i8],[200 x i8]* @"+idStr+",i32 0,i32 0");
                int strPoint=globalInitializationsId;
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = call i8* (i8*,i8*) @strcpy(i8* %"+strPoint+",i8* %"+a.value.get(j).regId+")");
                globalInitializations.append("\nstore i8* %"+strPoint+",i8** %"+id);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds "+a.type+","+a.type+"* @"+i+",i32 0,i32 "+j);
                storeGlobalRowStringsR(globalInitializationsId,a.arraysInside.get(j));
            }
        }
    }
    public String getCondIrOp(operations cond,boolean integer){
        if(cond==operations.LESS){
            if(integer) return "slt";
            else return "olt";
        }
        else if(cond==operations.GRT){
            if(integer) return "sgt";
            else return "ogt";
        }
        else if(cond==operations.LSE){
            if(integer) return "sle";
            else return "ole";
        }
        else if(cond==operations.GRE){
            if(integer) return "sge";
            else return "oge";
        }
        else if(cond==operations.EQ){
            if(integer) return "eq";
            else return "oeq";
        }
        else return "ERROR";
    }
    public void report_error(String message, Object info) {
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
:};

action code{:
    
:};

terminal LET,VAR,DOUBLEVAL,INTVAL;
terminal String ID,STRINGVAL,STRINGVALS,STRINGVALI,STRINGVALE;
terminal C,EQ,COL,BO,BC,GO,GC,ARROW;
terminal STRING,DOUBLE,INT,FUNC,USCORE;
terminal PLUS,MINUS,DIV,MUL;
terminal LESS,GREATER,LESSEQ,GREATEREQ,AND,OR,EQUAL,NOT;
terminal ELIF,ELSE,IF,FOR,IN,WHILE,DOT;
terminal QO,QC,INOUT;
terminal PRINT,RETURN;
terminal BREAK,CONTINUE,DEREF;
terminal uminus;

non terminal PROG,DEC,IFCOMPLETEBLOCK,RET,ASS,STMS,STM,FUNCTION,FSTMTS,FSTM,CONDSTM,CONDSTMS,WHILECOND,FORCOND;
non terminal HashMap<String,Value> IDINITlist;
non terminal Tuple INIT;
non terminal ArrayList<String> IDlist;
non terminal Value TYPE,TList,T,FTYPE;
non terminal Attribute VAL,ATTR,EXP,PROC,STR,IDARR,CPAR,IFCC,IFCOND,CONDATTR,COND;
non terminal operations OP,CONDOP;
non terminal Parameter PAR;
non terminal ArrayList<Parameter> PARlist;
non terminal ArrayList<Attribute> CPARlist,CPAREList,EXPL,HEXPL;
non terminal String RETVAL;
non terminal Boolean INOUTF,DOTRANGE;
non terminal Integer STRINGVALINTERP,IFCONDDEC,WHILEDEF;
non terminal Function FUNCDef;
non terminal ArrayDec ARRVALE,ARRVAL;

precedence left PLUS,MINUS,OR;
precedence left MUL,DIV,AND;
precedence left uminus;

start with PROG;

PROG::= {:scopes.add(globalScope);:} STMS {:
    if(errors==0)   System.out.println(";DEPENDENCY DECLARATIONS\ndeclare i32 @printf(i8*, ...)\ndeclare i32 @sprintf(i8*,i8*, ...)\ndeclare i8* @strcat(i8*,i8*)\ndeclare i8* @strcpy(i8*,i8*)\n@.str.newline = constant [2 x i8] c\"\\0A\\00\"\n@.str.int = constant [3 x i8] c\"%d\\00\"\n@.str.double = constant [4 x i8] c\"%lf\\00\"\n@.str.space = constant [2 x i8] c\" \\00\"\n;GLOBAL DECLARATIONS\n"
+globalBuffer+"\n;GLOBAL INITIALIZATIONS OF GLOBAL VARIABLES THAT ARE STRINGS OR ARRAYS OF STRINGS\ndefine void @globalinit(){"+globalInitializations+"\nret void\n}\n"+outputBuffer+"\n");
    else System.out.println("There were "+errors+"errors, here there are:\n"+ errorBuffer);
:} ;

//declarations of variables

DEC::= LET IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        if(t.initialized){
            if(t.array){
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                String base=dec.getBaseType();
                if(dec.allImmediates){
                    if(base.equals("double") || base.equals("i32")) globalBuffer.append("\n@"+a+" = global "+dec.type+" "+dec.printValue());
                    else{
                        globalBuffer.append("\n@"+a+" = global "+dec.type+" zeroinitializer");
                        storeGlobalRowStrings(a,dec);
                    }
                }
                else{
                    errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
                    errors++;
                }
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                if(att.type.equals("double") || att.type.equals("i32")) globalBuffer.append("\n@"+a+"= global "+t.irDec()+" "+att.getReg()+",align 4");
                else{
                    globalBuffer.append("\n@"+a+".arr = global [200 x i8] zeroinitializer");
                    globalBuffer.append("\n@"+a+" = global i8* getelementptr inbounds([200 x i8],[200 x i8]* @"+a+".arr,i32 0,i32 0)");
                    globalInitializations.append("\n%"+(++globalInitializationsId)+"= load i8*,i8** @"+a);
                    int strptr=globalInitializationsId;
                    globalInitializations.append("\n%"+(++globalInitializationsId)+" = call i8* (i8*,i8*) @strcpy(i8* %"+strptr+",i8* %"+att.regId+")");
                }
            }
        }
        else globalBuffer.append("\n@"+a+" = global "+t.irDec()+" zeroinitializer");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
    else{
        int id=getId();
        append("\n%"+id+"= alloca "+t.irDec()+",align 4");
        if(t.initialized){
            if(t.array){
                int i=getCurrentId();
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                storeRow(i,dec);
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                if(att.type.equals("i8*")){
                    int idStr,strPoint;
                    append("\n%"+getId()+"= alloca [200 x i8]");
                    idStr=getCurrentId();
                    append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+idStr+",i32 0,i32 0");
                    strPoint=getCurrentId();
                    append("\n%"+getId()+"= call i8* (i8*,i8*) @strcpy(i8* %"+strPoint+",i8* "+att.getReg()+")");
                    append("\nstore i8* %"+strPoint+",i8** %"+id);
                }
                else    append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
            }
        }
        Value v=new Value(t);
        v.setReg(id);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
});:} | VAR IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        if(t.initialized){
            if(t.array){
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                String base=dec.getBaseType();
                if(dec.allImmediates){
                    if(base.equals("double") || base.equals("i32")) globalBuffer.append("\n@"+a+" = global "+dec.type+" "+dec.printValue());
                    else{
                        globalBuffer.append("\n@"+a+" = global "+dec.type+" zeroinitializer");
                        storeGlobalRowStrings(a,dec);
                    }
                }
                else{
                    errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
                    errors++;
                }
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                if(att.type.equals("double") || att.type.equals("i32")) globalBuffer.append("\n@"+a+"= global "+t.irDec()+" "+att.getReg()+",align 4");
                else{
                    globalBuffer.append("\n@"+a+".arr = global [200 x i8] zeroinitializer");
                    globalBuffer.append("\n@"+a+" = global i8* getelementptr inbounds([200 x i8],[200 x i8]* @"+a+".arr,i32 0,i32 0)");
                    globalInitializations.append("\n%"+(++globalInitializationsId)+" load i8*,i8** @"+a);
                    int strptr=globalInitializationsId;
                    globalInitializations.append("\n%"+(++globalInitializationsId)+" = call i8* (i8*,i8*) @strcpy(i8* %"+strptr+",i8* %"+att.regId+")");
                }
            }
        }
        else globalBuffer.append("\n@"+a+" = global "+t.irDec()+" zeroinitializer");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
    else{
        int id=getId();
        append("\n%"+id+"= alloca "+t.irDec()+",align 4");
        if(t.initialized){
            if(t.array){
                int i=getCurrentId();
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                storeRow(i,dec);
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                if(att.type.equals("i8*")){
                    int idStr,strPoint;
                    append("\n%"+getId()+"= alloca [200 x i8]");
                    idStr=getCurrentId();
                    append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+idStr+",i32 0,i32 0");
                    strPoint=getCurrentId();
                    append("\n%"+getId()+"= call i8* (i8*,i8*) @strcpy(i8* %"+strPoint+",i8* "+att.getReg()+")");
                    append("\nstore i8* %"+strPoint+",i8** %"+id);
                }
                else    append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
            }
        }
        Value v=new Value(t);
        v.setReg(id);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
});:} | LET IDINITlist:l {:
    scopes.get(scopes.size()-1).constants.putAll(l);
:} | VAR IDINITlist:l {:
    scopes.get(scopes.size()-1).variables.putAll(l);
:};

IDlist::= IDlist:l C ID:x {: ArrayList<String> arr= new ArrayList<String>(l);
                            arr.add(x);
                            RESULT=arr;:}| ID:x{:ArrayList<String> arr= new ArrayList<String>();
                            arr.add(x);
                            RESULT=arr;:};

IDINITlist::= IDINITlist:l C INIT:i {:
    if(i!=null) l.put(i.name,i.value);
    RESULT=l;
:} | INIT:i {:
    HashMap<String,Value> res=new HashMap<String,Value>();
    if(i!=null) res.put(i.name,i.value);
    RESULT=res;
:};

INIT::= ID:i EQ VAL:l {:
    if(inFunction){
        int id=getId();
        append("\n%"+id+"= alloca "+l.type+",align 4");
        append("\nstore "+l.type+" "+l.getReg()+","+l.type+"* %"+id);
        Value v=new Value(l.type);
        v.setImmediateInit(l);
        v.setReg(id);
        RESULT=new Tuple(i,v);
    }
    else{
        if(l.immediate){
            globalBuffer.append("\n@"+i+" = global "+l.type+" "+l.getReg());
            Value v=new Value(l.type);
            v.setImmediateInit(l);
            v.setReg(i);
            RESULT=new Tuple(i,v);
        }
        else{
            errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
            errors++;
            RESULT=null;
        }
    }
:} | ID:i EQ ARRVALE:l {:
    if(inFunction){
        int id=getId();
        append("\n%"+id+"= alloca "+l.type+",align 4");
        storeRow(id,l);
        Value v=new Value(l.getBaseType());
        ArrayList<Integer> dimensions=l.getDimensions();
        dimensions.forEach(e->v.addArrLevel(e));
        v.setImmediateInit(l);
        v.setReg(id);
        RESULT=new Tuple(i,v);
    }
    else{
        if(l.allImmediates){
            globalBuffer.append("\n@"+i+" = global "+l.type+" "+l.printValue());
            Value v=new Value(l.getBaseType());
            ArrayList<Integer> dimensions=l.getDimensions();
            dimensions.forEach(e->v.addArrLevel(e));
            v.setImmediateInit(l);
            v.setReg(i);
            RESULT=new Tuple(i,v);
        }
        else{
            errorBuffer.append("\nCannot initialize a global variable that doesn't have static values");
            errors++;
            RESULT=null;
        }
    }
:} ;

TYPE::= COL TList:t {:RESULT=t;:}| COL TList:t EQ VAL:v {:
    t.setImmediateInit(v);
    RESULT=t;
:} | COL TList:t EQ ARRVALE:l {:
    t.setArrDimensions(l.getDimensions());
    t.setImmediateInit(l);
    RESULT=t;
:};

VAL::= DOUBLEVAL:v {:RESULT=new Attribute(v,"double");:}| INTVAL:v {:RESULT=new Attribute(v,"i32");:}| STR:v {:RESULT=v;:};

STR::= STRINGVAL:s {:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    int id;
    if(inFunction){
        append("\n%"+getId()+" = getelementptr inbounds ["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0");
        RESULT=new Attribute("i8*",getCurrentId());
    }
    else{
        globalInitializations.append("\n%"+(++globalInitializationsId)+" = getelementptr inbounds ["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0");
        Attribute att=new Attribute("i8*",globalInitializationsId);
        att.immediate=true;
        RESULT=att;
    }
:}| STRINGVALS:s STRINGVALINTERP:i STRINGVALE:e{:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(e.length()+1)+" x i8] c\""+e+"\\00\"");
    int stringArrPointer;
    int stringGepPointer;
    append("\n%"+getId()+" = alloca [200 x i8], align 1");
    stringArrPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [200 x i8], [200 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
    stringGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+(stringIndex-1)+", i32 0, i32 0))");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* %"+i+")");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(e.length()+1)+" x i8], ["+(e.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0))");
    RESULT=new Attribute("i8*",stringGepPointer);
:};

STRINGVALINTERP::= STRINGVALINTERP:i STRINGVALI:s EXP:e {:
    int expPointer,expGep,finalArrPointer,finalGepPointer;
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    append("\n%"+getId()+" = alloca [200 x i8], align 1");
    finalArrPointer=getCurrentId();
    append("\n%"+getId()+" = alloca [20 x i8], align 1");
    expPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+expPointer+" , i32 0, i32 0");
    expGep=getCurrentId();
    if(e!=null){
        if(e.type.equals("i32"))   append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+expGep+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
        else if(e.type.equals("double"))   append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+expGep+",i8* getelementptr inbounds([4 x i8], [4 x i8]* @.str.double, i32 0, i32 0), double "+e.getReg()+")");
        else{
            errors++;
            errorBuffer.append("\nString interpolation is allowed only with expressions that are either doubles or integers");
            append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+expGep+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 -1)");
        }
    }
    else    append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+expGep+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 -1)");
    append("\n%"+getId()+" = getelementptr inbounds [200 x i8],[200 x i8]* %"+finalArrPointer+",i32 0,i32 0");
    finalGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+finalGepPointer+",i8* %"+i+")");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+finalGepPointer+",i8* getelementptr inbounds (["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+stringIndex+",i32 0,i32 0))");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+finalGepPointer+",i8* %"+expGep+")");
    RESULT=finalGepPointer;
:}| EXP:e {:
    int stringArrPointer;
    int stringGepPointer;
    append("\n%"+getId()+" = alloca [20 x i8], align 1");
    stringArrPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
    stringGepPointer=getCurrentId();
    if(e!=null){
        if(e.type.equals("i32"))   append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
        else if(e.type.equals("double"))   append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([4 x i8], [4 x i8]* @.str.double, i32 0, i32 0), double "+e.getReg()+")");
        else{
            errors++;
            errorBuffer.append("\nString interpolation is allowed only with expressions that are either doubles or integers");
            append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 -1)");
        }
    }
    else    append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 -1)");
    RESULT=stringGepPointer;
:};


ARRVALE::= QO ARRVALE:l QC {:
    l.close();
    RESULT=l;
:}| ARRVALE:l C ARRVALE:a {:
    if(l.closed && a.closed){
        ArrayList<ArrayDec> arr=new ArrayList<ArrayDec>();
        arr.add(l);
        arr.add(a);
        RESULT=new ArrayDec(arr,a.type,false,a.allImmediates&&l.allImmediates);
    }
    else{
        a.arraysInside.add(0,l);
        a.allImmediates=a.allImmediates&&l.allImmediates;
        RESULT=a;
    }
:}| ARRVAL:a {:RESULT=a;:};

ARRVAL::= QO EXPL:l QC {:
    boolean allImmediates=true;
    for(int i=0;i<l.size();i++){
        if(!l.get(i).immediate){
            allImmediates=false;
            break;
        }
    }
    RESULT=new ArrayDec("["+l.size()+" x "+l.get(0).type+"]",l,true,allImmediates);
:};

HEXPL::= HEXPL:l C EXP:e {:
    if(e!=null) l.add(e);
    RESULT=l;
:} | EXP:e {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    if(e!=null) l.add(e);
    RESULT=l;
:} | {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    RESULT=l;
:};

EXPL::= EXPL:l C EXP:e {:
    if(e!=null){
        if(l.get(l.size()-1).type.equals(e.type)) l.add(e);
        else{
            errors++;
            errorBuffer.append("\nCannot have heterogenous arrays");
        }
    }
    RESULT=l;
:} | EXP:e {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    if(e!=null) l.add(e);
    RESULT=l;
:} | ;

TList::= QO TList:t QC {:
    t.addArrLevel();
    RESULT=t;
:}| T:t {:RESULT=t;:};

T::=STRING {:RESULT=new Value(true);:}| DOUBLE {:RESULT=new Value(false);:}| INT{:RESULT=new Value(32);:} ;

//assignment

ASS::= ID:a EQ EXP:e {:
    Tuple t=getValue(a);
    Value v=null;
    if(t!=null){
        if(t.value.initialized && t.name.equals("let")){
            errorBuffer.append("\nConstant "+a+" has already been assigned");
            errors++;
            RESULT=null;
        }
        else    v=t.value;
    }
    if(v==null || e==null)  RESULT=null;
    else{
        String type=v.irDec();
        if(v.inoutPar && !v.array)  type=v.getBaseType();
        if(!e.type.equals(type)){
            errors++;
            errorBuffer.append("\nType mismatch in assignment, a has type "+type+", while e has type "+e.type);
        }
    //System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
        else if(e.type.equals("i8*")){
            append("\n%"+getId()+"= load i8*,i8** "+v.getReg());
            int idA=getCurrentId();
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idA+",i8* "+e.getReg()+")");
            v.initialized=true;
        }
        else{
            append("\nstore "+type+" "+e.getReg()+","+type+"* "+v.getReg());
            v.initialized=true;
        }
    }
:} | IDARR:a EQ EXP:e {:
    if(a==null || e==null)  RESULT=null;
    Tuple t=getValue(a.associatedVarName);
    Value v=null;
    if(t!=null){
        if(t.name.equals("let") && t.value.initialized){
            errorBuffer.append("\nConstant "+a.associatedVarName+" has already been assigned");
            errors++;
            RESULT=null;
        }
        else v=t.value;
    }
    if(v==null) RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
    }
    else{
        if(e.type.equals("i8*")){
            append("\n%"+getId()+"= load i8*,i8** "+a.getReg());
            int idA=getCurrentId();
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idA+",i8* "+e.getReg()+")");
        }
        else{
            append("\nstore "+e.type+" "+e.getReg()+","+e.type+"* "+a.getReg());
        }
    }
:} | ID:a OP:op EQ EXP:e {:
    Tuple t=getValue(a);
    Value v=null;
    if(t!=null){
        if(t.name.equals("let")){
            errorBuffer.append("\nConstants like "+a+" cannot be used with += -= *= /= operators");
            errors++;
            RESULT=null;
        }
        else v=t.value;
    }
    if(v==null || e==null) RESULT=null;
    else if(!v.initialized){
        errorBuffer.append("\nVariable "+a+" hasn't been initialized yet so it cannot be used with += -= *= /= operators");
        errors++;
        RESULT=null;
    }
    else if(!e.type.equals(v.irDec())){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
        RESULT=null;
    }
    //System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
    else{
        String type=v.irDec();
        if(type.equals("i8*")){
            if(op==operations.ADD){
                append("\n%"+getId()+"= alloca [200 x i8]");
                int newArr=getCurrentId();
                append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+newArr+",i32 0, i32 0");
                int idPointer=getCurrentId();
                append("\n%"+getId()+"= load i8*,i8** "+v.getReg());
                int idA=getCurrentId();
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idPointer+",i8* %"+idA+")");
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+idPointer+",i8* "+e.getReg()+")");
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idA+",i8* %"+idPointer+")");
            }
            else errorBuffer.append("\nonly operation allowed on string is the add");
        }
        else{
            int id;
            append("\n%"+getId()+"= load "+type+","+type+"* "+v.getReg());
            id=getCurrentId();
            append("\n%"+getId()+" = "+getIrOp(op,e.type)+" "+e.type+" %"+id+","+e.getReg());
            append("\nstore "+e.type+" %"+getCurrentId()+","+e.type+"* "+v.getReg());
        }
    }
:} | IDARR:a OP:op EQ EXP:e {:
    if(a==null || e==null)  RESULT=null;
    Tuple t=getValue(a.associatedVarName);
    Value v=null;
    if(t!=null){
        if(t.name.equals("let")){
            errorBuffer.append("\nConstants like "+a.associatedVarName+" cannot be used with += -= *= /= operators");
            errors++;
            RESULT=null;
        }
        else{
            v=t.value;
            if(!t.value.initialized){
                errorBuffer.append("\nVariable "+a.associatedVarName+" hasn't ben assigned yet");
                errors++;
                v=null;
                RESULT=null;
            }
        }
    }
    if(v==null) RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment");
    }
    else{
        String type=a.type;
        if(type.equals("i8*")){
            if(op==operations.ADD){
                append("\n%"+getId()+"= alloca [200 x i8]");
                int newArr=getCurrentId();
                append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+newArr+",i32 0, i32 0");
                int idPointer=getCurrentId();
                append("\n%"+getId()+"= load i8*,i8** "+a.getReg());
                int idA=getCurrentId();
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idPointer+",i8* %"+idA+")");
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+idPointer+",i8* "+e.getReg()+")");
                append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idA+",i8* %"+idPointer+")");
            }
            else errorBuffer.append("\nonly operation allowed on string is the add");
        }
        else{
            int id;
            append("\n%"+getId()+"= load "+type+","+type+"* "+a.getReg());
            id=getCurrentId();
            append("\n%"+getId()+" = "+getIrOp(op,e.type)+" "+e.type+" %"+id+","+e.getReg());
            append("\nstore "+e.type+" %"+getCurrentId()+","+e.type+"* "+a.getReg());
        }
    }
:};

CPAR::= ID:name COL EXP:e {:
    int np=callingFunctionPar.get(callingFunctionPar.size()-1);
    String nameF=callingFunction.get(callingFunction.size()-1);
    Function f=null;
    Parameter p=null;
    if(functions.containsKey(nameF)){
        f=functions.get(nameF);
        if(np<=f.pars.size()-1) p=f.pars.get(np);
    }
    if(e==null || f==null || p==null) RESULT=null;
    else{
        if(p.argLabel){
            if(!p.label.equals(name)){
                errorBuffer.append("\nExpected "+p.label+" as the label for the parameter instead received "+name);
                errors++;
            }
        }
        else{
            errorBuffer.append("\nDidn't expect a label for the parameter instead received "+name);
            errors++;
        }
        if(p.type.inoutPar){
            errorBuffer.append("\nExpected an inout parameter, use the & operator");
            errors++;
        }
        if(!p.type.irDec().equals(e.type)){
            errorBuffer.append("\nType mismatch in parameter passing");
            errors++;
        }
        RESULT=e;
    }
:} | EXP:e {:
    int np=callingFunctionPar.get(callingFunctionPar.size()-1);
    String nameF=callingFunction.get(callingFunction.size()-1);
    Function f=null;
    Parameter p=null;
    if(functions.containsKey(nameF)){
        f=functions.get(nameF);
        if(np<=f.pars.size()-1) p=f.pars.get(np);
    }
    if(e==null || f==null || p==null) RESULT=null;
    else{
        if(p.argLabel){
            errorBuffer.append("\nExpected "+p.label+" as the label for the parameter instead the label is missing");
            errors++;
        }
        if(p.type.inoutPar){
            errorBuffer.append("\nExpected an inout parameter, use the & operator");
            errors++;
        }
        if(!p.type.irDec().equals(e.type)){
            errorBuffer.append("\nType mismatch in parameter passing p has type: "+p.type.irDec()+", while e has type "+e.type);
            errors++;
        }
        RESULT=e;
    }
:} | DEREF:d EXP:e {:
    int np=callingFunctionPar.get(callingFunctionPar.size()-1);
    String nameF=callingFunction.get(callingFunction.size()-1);
    Function f=null;
    Parameter p=null;
    if(functions.containsKey(nameF)){
        f=functions.get(nameF);
        if(np<=f.pars.size()-1) p=f.pars.get(np);
    }
    if(e==null || f==null || p==null) RESULT=null;
    else{
        if(p.argLabel){
            errorBuffer.append("\nExpected "+p.label+" as the label for the parameter instead the label is missing");
            errors++;
        }
        if(!p.type.inoutPar){
            errorBuffer.append("\nTrying to dereferenciate while the parameter is not inout");
            errors++;
        }
        if(e.associatedVarName==null){
            errorBuffer.append("\nAn inout parameter must be always a variable");
            errors++;
        }
        if(!p.type.irDec().equals(e.type)){
            errorBuffer.append("\nType mismatch in parameter passing, expected "+p.type.irDec()+", and receiving "+e.type);
            errors++;
        }
        RESULT=e;
    }
:} | ID:name COL DEREF EXP:e {:
    int np=callingFunctionPar.get(callingFunctionPar.size()-1);
    String nameF=callingFunction.get(callingFunction.size()-1);
    Function f=null;
    Parameter p=null;
    if(functions.containsKey(nameF)){
        f=functions.get(nameF);
        if(np<=f.pars.size()-1) p=f.pars.get(np);
    }
    if(e==null || f==null || p==null) RESULT=null;
    else{
        if(p.argLabel){
            if(!p.label.equals(name)){
                errorBuffer.append("\nExpected "+p.label+" as the label for the parameter instead received "+name);
                errors++;
            }
        }
        else{
            errorBuffer.append("\nDidn't expect a label for the parameter instead received "+name);
            errors++;
        }
        if(!p.type.inoutPar){
            errorBuffer.append("\nTrying to dereferenciate while the parameter is not inout");
            errors++;
        }
        if(e.associatedVarName==null){
            errorBuffer.append("\nAn inout parameter must be always a variable");
            errors++;
        }
        if(!p.type.irDec().equals(e.type)){
            errorBuffer.append("\nType mismatch in parameter passing");
            errors++;
        }
        RESULT=e;
    }
:};

EXP::= EXP:e PLUS EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment, e has type "+e.type+",while a has type "+a.type);
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32") && !e.type.equals("i8*")){
        errorBuffer.append("\nCan do substractions only on integeres,strings and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.type.equals("i8*")){
            append("\n%"+getId()+"= alloca [200 x i8]");
            int newArr=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+newArr+",i32 0, i32 0");
            id=getCurrentId();
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+id+",i8* "+e.getReg()+")");
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+id+",i8* "+a.getReg()+")");
            RESULT=new Attribute("i8*",id);
        }
        else{
            if(e.immediate){
                if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
                else append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
            }
            else{
                if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
                else append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
            }
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:}| ATTR:a {:
    RESULT=a;
:}| EXP:e MINUS EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment, e has type "+e.type+",while a has type "+a.type);
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32")){
        errorBuffer.append("\nCan do substractions only on integeres and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.immediate){
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
        }
        else{
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:} | EXP:e MUL EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment, e has type "+e.type+",while a has type "+a.type);
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32")){
        errorBuffer.append("\nCan do multiplications only on integeres and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.immediate){
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
        }
        else{
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:} | EXP:e DIV EXP:a {:
    if(e==null || a==null)  RESULT=null;
    else if(!e.type.equals(a.type)){
        errors++;
        errorBuffer.append("\nType mismatch in assignment, e has type "+e.type+",while a has type "+a.type);
        RESULT=e;
    }
    else if(!e.type.equals("double") && !e.type.equals("i32")){
        errorBuffer.append("\nCan do divisions only on integeres and doubles!");
        errors++;
        RESULT=e;
    }
    else{
        int id;
        if(e.immediate){
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
        }
        else{
            if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
            else append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
        }
        id=getCurrentId();
        RESULT=new Attribute(e.type,id);
    }
:} | BO EXP:e BC {:RESULT=e;:}
| MINUS EXP:e {:
    if(e!=null){
        if(e.type.equals("i32")){
            append("\n%"+getId()+" = sub i32 0,"+e.getReg());
            RESULT=new Attribute(e.type,getCurrentId());
        }
        else if(e.type.equals("double")){
            append("\n%"+getId()+" = fsub double 0,"+e.getReg());
            RESULT=new Attribute(e.type,getCurrentId());
        }
        else{
            errorBuffer.append("\nCannot do a substraction to a value that is not an integer or a double");
            errors++;
            RESULT=null;
        }
    }
    else RESULT=null;
:} %prec uminus;


ATTR::= PROC:p {:
    RESULT=p;
:} | ID:i {:
    Tuple t=getValue(i);
    Value v=null;
    if(t!=null) v=t.value;
    if(v==null) RESULT=null;
    else if(!v.initialized){
        errors++;
        errorBuffer.append("\nValue "+i+" hasn't already been initialized before this expression");
        RESULT=null;
    }
    else{
        String type=v.irDec();
        String reg=v.getReg();
        int id;
        if(callingFunction.size()>0){
            int np=callingFunctionPar.get(callingFunctionPar.size()-1);
            String nameF=callingFunction.get(callingFunction.size()-1);
            Function f=null;
            Parameter p=null;
            if(functions.containsKey(nameF)){
                f=functions.get(nameF);
                if(np<=f.pars.size()-1) p=f.pars.get(np);
            }
            if(f!=null && p!=null){
                if(v.array){
                    if(v.funcPar){
                        append("\n%"+getId()+" = load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
                        RESULT=new Attribute(v.irDec(),i,getCurrentId(),v.dimensionsParameters);
                    }
                    else{
                        int lastId=-1;
                        ArrayList<Integer> subdim=new ArrayList<Integer>();
                        for(int j=0;j<v.dimensions.size();j++){
                            String newType,subir;
                            if(j==0){
                                append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* "+v.getReg()+",i32 0,i32 0");
                                subir=type.substring(1,type.length()-1);
                                if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                                else newType=subir.substring(subir.indexOf("["),subir.length());
                                type=newType;
                                lastId=getCurrentId();
                            }
                            else{
                                append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* %"+lastId+",i32 0,i32 0");
                                subir=type.substring(1,type.length()-1);
                                if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                                else newType=subir.substring(subir.indexOf("["),subir.length());
                                type=newType;
                                lastId=getCurrentId();
                                subdim.add(v.dimensions.get(j));
                            }
                        }
                        if(subdim.size()>0) RESULT=new Attribute(type+"*",i,subdim,lastId);
                        else RESULT=new Attribute(type+"*",lastId,i);
                    }
                }
                else if(type.equals("i8*")){
                    append("\n%"+getId()+"= load "+type+","+type+"* "+reg);
                    id=getCurrentId();
                    RESULT=new Attribute(type,id,i);
                }
                else if(type.equals("double") || type.equals("i32")){
                    if(!p.type.inoutPar){
                        append("\n%"+getId()+"= load "+type+","+type+"* "+v.getReg());
                        RESULT=new Attribute(type,getCurrentId(),i);
                    }
                    else    RESULT=new Attribute(type+"*",v.getReg(),i);
                }
                else RESULT=null;
            }
            else    RESULT=null;
        }
        else{
            if(v.inoutPar && !v.array)  type=v.getBaseType();
            if(type.equals("double") || type.equals("i32") || type.equals("i8*")){
                append("\n%"+getId()+"= load "+type+","+type+"* "+reg);
                id=getCurrentId();
                RESULT=new Attribute(type,id,i);
            }
            else{
                errorBuffer.append("\nCan't use an array in an expression,type "+v.irDec());
                errors++;
                RESULT=null;
            }
        }
    }
:} | VAL:v {:
    RESULT=v;
:} | IDARR:i {:
    int id;
    if(i==null) RESULT=null;
    else{
        Tuple t=getValue(i.associatedVarName);
        Value v=null;
        if(t!=null) v=t.value;
        String type=v.irDec();
        if(callingFunction.size()>0){
            int np=callingFunctionPar.get(callingFunctionPar.size()-1);
            String nameF=callingFunction.get(callingFunction.size()-1);
            Function f=null;
            Parameter p=null;
            if(functions.containsKey(nameF)){
                f=functions.get(nameF);
                if(np<=f.pars.size()-1) p=f.pars.get(np);
            }
            if(f!=null && p!=null){
                if(i.arrVar){
                    if(i.arrFunc){
                        String baseType=v.getBaseType();
                        append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+v.getReg());
                        int loadId=getCurrentId();
                        append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+i.type+" %"+loadId+", i32 "+i.getReg());
                        RESULT=new Attribute(i.type,i.associatedVarName,getCurrentId(),i.dimensions);
                    }
                    else{
                        String subir,newType="",ir=i.type;
                        int lastId=i.regId;
                        ArrayList<Integer> subdim=new ArrayList<Integer>();
                        for(int po=0;po<i.dimensionsInt.size();po++){
                            append("\n%"+getId()+" = getelementptr inbounds "+ir+","+ir+"* %"+lastId+", i32 0, i32 0");
                            lastId=getCurrentId();
                            subir=ir.substring(1,ir.length()-1);
                            if(po!=i.dimensionsInt.size()-1){
                                newType=subir.substring(subir.indexOf("["),subir.length());
                            }
                            else{
                                newType=subir.substring(subir.indexOf("x")+2,subir.length());
                            }
                            ir=newType;
                            if(po>0) subdim.add(i.dimensionsInt.get(po));
                        }
                        if(subdim.size()>0)    RESULT=new Attribute(newType+"*",i.associatedVarName,subdim,lastId);
                        else    RESULT=new Attribute(newType+"*",lastId,i.associatedVarName);
                    }
                }
                else if(i.type.equals("i8*")){
                    append("\n%"+getId()+"= load i8*,i8** "+i.getReg());
                    id=getCurrentId();
                    RESULT=new Attribute("i8*",id,i.associatedVarName);
                }
                else if(i.type.equals("double") || i.type.equals("i32")){
                    if(!p.type.inoutPar){
                        append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+i.getReg());
                        RESULT=new Attribute(i.type,getCurrentId(),i.associatedVarName);
                    }
                    else    RESULT=new Attribute(i.type+"*",i.getReg(),i.associatedVarName);
                }
                else RESULT=null;
            }
        }
        else{
            if(i.type.equals("i32") || i.type.equals("double") || i.type.equals("i8*")){
                append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+i.getReg());
                id=getCurrentId();
                RESULT=new Attribute(i.type,id);
            }
            else RESULT=null;
        }
    }
:} ;

IDARR::= IDARR:i QO EXP:a QC {:
    if(i.arrFunc){
        if(i.dimensions.size()>0){
            ArrayList<String> s=new ArrayList<String>();
            for(int j=0;j<i.dimensions.size();j++){
                if(j==0)    append("\n%"+getId()+"= mul i32 %"+i.dimensions.get(j)+","+a.getReg());
                else{
                    int oldId=getCurrentId();
                    append("\n%"+getId()+"= mul i32 %"+oldId+",%"+i.dimensions.get(j));
                    s.add(i.dimensions.get(j));
                }
            }
            int lastId=getCurrentId();
            append("\n%"+getId()+"= add nsw i32 %"+lastId+","+i.getReg());
            RESULT=new Attribute(i.type,i.associatedVarName,getCurrentId(),s);
        }
        else{
            append("\n%"+getId()+"= add nsw i32 "+a.getReg()+","+i.getReg());
            int lastId=getCurrentId();
            Tuple t=getValue(i.associatedVarName);
            Value v=null;
            if(t!=null) v=t.value;
            String baseType=v.getBaseType();
            append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+v.getReg());
            int loadId=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+i.type+" %"+loadId+", i32 %"+lastId);
            RESULT=new Attribute(baseType,getCurrentId(),i.associatedVarName);
        }
    }
    else{
        String ir=i.type;
        append("\n%"+getId()+" = getelementptr inbounds "+i.type+","+i.type+"* "+i.getReg()+", i32 0, i32 "+a.getReg());
        String subir=ir.substring(1,ir.length()-1);
        String newType;
        if(subir.indexOf("[")<0){
            newType=subir.substring(subir.indexOf("x")+2,subir.length());
            RESULT=new Attribute(newType,getCurrentId(),i.associatedVarName);
        }
        else{
            newType=subir.substring(subir.indexOf("["),subir.length());
            ArrayList<Integer> subdim=new ArrayList<Integer>();
            for(int at=1;at<i.dimensionsInt.size();at++) subdim.add(i.dimensionsInt.get(at));
            RESULT=new Attribute(newType,i.associatedVarName,subdim,getCurrentId());
        }
    }
:} | ID:i QO EXP:a QC {:
    Tuple t=getValue(i);
    Value v=null;
    if(t!=null) v=t.value;
    if(v==null){
        errorBuffer.append("\nValue "+i+" has not been declared yet");
        errors++;
        RESULT=null;
    }
    else if(!v.array){
        errorBuffer.append("\nValue "+i+" is not an array");
        errors++;
        RESULT=null;
    }
    else if(!v.initialized){
        errorBuffer.append("\nValue "+i+" has not been initialized yet");
        errors++;
        RESULT=null;
    }
    else{
        if(v.funcPar && v.dimensions.size()>1){
            ArrayList<String> s=new ArrayList<String>();
            for(int j=0;j<v.dimensionsParameters.size();j++){
                if(j==0)    append("\n%"+getId()+"= mul i32 %"+v.dimensionsParameters.get(j)+","+a.getReg());
                else{
                    int oldId=getCurrentId();
                    append("\n%"+getId()+"= mul i32 %"+oldId+",%"+v.dimensionsParameters.get(j));
                    s.add(v.dimensionsParameters.get(j));
                }
            }
            RESULT=new Attribute(v.irDec(),i,getCurrentId(),s);
        }
        else if(v.funcPar && v.dimensions.size()==1){
            String baseType=v.getBaseType();
            append("\n%"+getId()+"= load "+baseType+"*,"+baseType+"** "+v.getReg());
            int loadId=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+baseType+"* %"+loadId+", i32 "+a.getReg());
            RESULT=new Attribute(baseType,getCurrentId(),i);
        }
        else{
            String ir=v.irDec();
            String reg=v.getReg();
            append("\n%"+getId()+" = getelementptr inbounds "+ir+","+ir+"* "+reg+", i32 0, i32 "+a.getReg());
            String subir=ir.substring(1,ir.length()-1);
            String newType;
            if(subir.indexOf("[")<0){
                newType=subir.substring(subir.indexOf("x")+2,subir.length());
                RESULT=new Attribute(newType,getCurrentId(),i);
            }
            else{
                newType=subir.substring(subir.indexOf("["),subir.length());
                ArrayList<Integer> subdim=new ArrayList<Integer>();
                for(int at=1;at<v.dimensions.size();at++) subdim.add(v.dimensions.get(at));
                RESULT=new Attribute(newType,i,subdim,getCurrentId());
            }
        }
    }
:} ;

OP::= PLUS {:RESULT=operations.ADD;:} | MINUS {:RESULT=operations.SUB;:} | MUL {:RESULT=operations.MUL;:} | DIV {:RESULT=operations.DIV;:} ;

//statements

STMS::= STMS STM | STM;

STM::=DEC | FUNCTION;

CONDSTMS::= CONDSTMS CONDSTM | ;

CONDSTM::= ASS | PROC | DEC | BREAK {:
    if(inConditional){
        append("\nbr label %for.exit."+forloops.get(forloops.size()-1));
        getId();
    }
    else {
        errorBuffer.append("Used continue statement while not in a for loop or while loop");
    }
:} | CONTINUE {:
    if(inConditional){
        append("\nbr label %for.inc."+forloops.get(forloops.size()-1));
        getId();
    }
    else {
        errorBuffer.append("Used continue statement while not in a for loop or while loop");
    }
:};

PROC::= ID:name {:
    callingFunction.add(name);
    callingFunctionPar.add(0);
:} BO CPAREList:l BC {:
    Function f=null;
    int id=0;
    if(functions.containsKey(name)){
        f=functions.get(name);
        String fParList="("+f.pars.stream().map(e->e.type.irDec()).collect(Collectors.joining(","))+")";
        if(!fParList.equals("("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")")){
            errorBuffer.append("\nPassing a wrong list of parameters to function "+name);
            errors++;
            f=null;
        }
        else{
            if(f.retType.equals("void"))    append("\ncall "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
            else{
                append("\n%"+(getId())+"=call "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
                id=getCurrentId();
            }
        }
    }
    callingFunctionPar.remove(callingFunctionPar.size()-1);
    callingFunction.remove(callingFunction.size()-1);
    if(f!=null) RESULT=new Attribute(f.retType,id);
    else{
        errorBuffer.append("\nCalling a function that either is not declared yet or doesn't exist at all");
        errors++;
        RESULT=null;
    }
:} | PRINT BO HEXPL:l BC{:
        l.forEach(p->{
            if(p.type.equals("i8*"))    append("\n%"+getId()+" = call i32 (i8*, ...) @printf(i8* "+p.getReg()+")");
            else if(p.type.equals("i32"))   append("\n%"+getId()+"= call i32 (i8*, ...) @printf(i8* getelementptr inbounds([3 x i8],[3 x i8]* @.str.int,i32 0,i32 0),i32 "+p.getReg()+")");
            else if(p.type.equals("double"))   append("\n%"+getId()+"= call i32 (i8*, ...) @printf(i8* getelementptr inbounds([4 x i8],[4 x i8]* @.str.double,i32 0,i32 0),double "+p.getReg()+")");
            else{
                errors++;
                errorBuffer.append("\nCan't print a type that is not a string, double or integer");
            }
            append("\n%"+getId()+"= call i32 (i8*, ...) @printf(i8* getelementptr inbounds([2 x i8],[2 x i8]* @.str.space,i32 0,i32 0))");
        });
        append("\n%"+getId()+" = call i32 (i8*, ...) @printf(i8* getelementptr inbounds([2 x i8], [2 x i8]* @.str.newline, i32 0, i32 0))");
:} ;

CPAREList::= CPARlist:l {:RESULT=l;:} | {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    RESULT=l;
:};

CPARlist::= CPARlist:l C CPAR:p {:
    if(p!=null){
        l.add(p);
        if(p.arrVar){
            if(p.arrFunc){
                for(int i=0;i<p.dimensions.size();i++){
                    append("\n%"+getId()+"= add nsw i32 0, %"+p.dimensions.get(i));
                    l.add(new Attribute("i32",getCurrentId()));
                }
                callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensions.size());
            }
            else{
                for(int i=0;i<p.dimensionsInt.size();i++)  l.add(new Attribute(p.dimensionsInt.get(i),"i32"));
                callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensionsInt.size());
            }
        }
    }
    RESULT=l;
:} | CPAR:p{:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    if(p!=null){
        l.add(p);
        if(p.arrVar){
            if(p.arrFunc){
                for(int i=0;i<p.dimensions.size();i++){
                    append("\n%"+getId()+"= load i32,i32* "+p.dimensions.get(i));
                    l.add(new Attribute("i32",getCurrentId()));
                }
                callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensions.size());
            }
            else{
                for(int i=0;i<p.dimensionsInt.size();i++)  l.add(new Attribute(p.dimensionsInt.get(i),"i32"));
                callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensionsInt.size());
            }
        }
    }
    RESULT=l;
:};


//control loop blocks

IFCOMPLETEBLOCK::= IFCC:ifc {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    append("\nbr label %if.exit."+ifc.type+".0");
    append("\nif.exit."+ifc.type+".0:");
:} | IFCC:ifc ELSE {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO CONDSTMS GC {:
    append("\nbr label %if.exit."+ifc.type+".0");
    append("\nif.exit."+ifc.type+".0:");
    scopes.remove(scopes.size()-1);
:};

IFCC::= IFCC:ifc ELIF {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
:} COND:cond {:
    append("\nbr i1 "+cond.getReg()+", label %if.body."+ifc.type+"."+ifc.regId+", label %if.elif."+ifc.type+"."+(ifc.regId+1));
    append("\nif.body."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO CONDSTMS GC {:
    append("\nbr label %if.exit."+ifc.type+".0");
    ifc.setReg(ifc.regId+1);
    scopes.remove(scopes.size()-1);
    RESULT=ifc;
:} | IFCOND:ifc {:RESULT=ifc;:};

IFCOND::= IFCONDDEC:ifNum GO CONDSTMS GC {:
    append("\nbr label %if.exit."+ifNum+".0");
    scopes.remove(scopes.size()-1);
    RESULT=new Attribute(""+ifNum,0);
:} | IFCONDDEC STM ;

IFCONDDEC::= IF COND:cond {:
    int currIf=currentIf++;
    append("\nbr i1 "+cond.getReg()+", label %if.body."+currIf+", label %if.elif."+currIf+".0");
    append("\nif.body."+currIf+":");
    scopes.add(new Scope());
    RESULT=currIf;
:};


WHILECOND::= WHILEDEF:wh COND:cond {:
    append("\nbr i1 "+cond.getReg()+", label %for.body."+wh+", label %for.exit."+wh);
    append("\nfor.body."+wh+":");
    scopes.add(new Scope());
    if(!inConditional)  inConditional=true;
    forloops.add(wh);
:} GO CONDSTMS GC {:
    append("\nbr label %for.inc."+wh);
    append("\nfor.inc."+wh+":");
    append("\n%"+getId()+" = add nsw i32 0,0");
    append("\nbr label %for.cond."+wh);
    append("\nfor.exit."+wh+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:};

WHILEDEF::= WHILE {:
    int currWh=currentFor++;
    append("\nbr label %for.cond."+currWh);
    append("\nfor.cond."+currWh+":");
    RESULT=currWh;
:};

DOTRANGE::= DOT DOT DOT {:RESULT=true;:} | DOT DOT LESS {:RESULT=false;:} ;

FORCOND::= FOR ID:index IN INTVAL:start DOTRANGE:d INTVAL:finish {:
    scopes.add(new Scope());
    int currFor=currentFor++;
    append("\nbr label %for.init."+currFor);
    append("\nfor.init."+currFor+":");
    append("\n%"+getId()+" = alloca i32, align 4");
    int indexId=getCurrentId();
    Value v=new Value(32);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    append("\nstore i32 "+start+",i32* %"+indexId);
    append("\nbr label %for.cond."+currFor);
    append("\nfor.cond."+currFor+":");
    append("\n%"+getId()+" = load i32,i32* %"+indexId);
    int idload=getCurrentId();
    if(d)   append("\n%"+getId()+" = icmp sle i32 %"+idload+","+finish);
    else    append("\n%"+getId()+" = icmp slt i32 %"+idload+","+finish);
    append("\nbr i1 %"+getCurrentId()+", label %for.body."+currFor+", label %for.exit."+currFor);
    append("\nfor.body."+currFor+":");
    if(!inConditional)  inConditional=true;
    forloops.add(currFor);
    RESULT=currFor;
:} GO CONDSTMS GC {:
    Value v=getValue(index).value;
    append("\nbr label %for.inc."+RESULT);
    append("\nfor.inc."+RESULT+":");
    append("\n%"+getId()+" = load i32,i32* "+v.getReg());
    int k=getCurrentId();
    append("\n%"+getId()+" = add nsw i32 %"+k+",1");
    append("\nstore i32 %"+getCurrentId()+",i32* "+v.getReg());
    append("\nbr label %for.cond."+RESULT);
    append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:} | FOR ID:index IN ID:start DOTRANGE:d ID:finish {:
    scopes.add(new Scope());
    int currFor=currentFor++;
    Tuple tstart=getValue(start),tfinish=getValue(finish);
    Value vstart=null,vfinish=null;
    if(tstart!=null && tfinish!=null){
        if(tstart.value.initialized && tfinish.value.initialized && tstart.value.irDec().equals("i32") && tfinish.value.irDec().equals("i32")){
            vstart=tstart.value;
            vfinish=tfinish.value;
        }
    }
    append("\nbr label %for.init."+currFor);
    append("\nfor.init."+currFor+":");
    append("\n%"+getId()+" = alloca i32, align 4");
    int indexId=getCurrentId();
    Value v=new Value(32);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    if(vstart!=null && vfinish!=null){
        append("\n%"+getId()+"= load i32,i32* "+vstart.getReg());
        append("\nstore i32 %"+getCurrentId()+",i32* %"+indexId);
        append("\nbr label %for.cond."+currFor);
        append("\nfor.cond."+currFor+":");
        append("\n%"+getId()+" = load i32,i32* %"+indexId);
        int idload=getCurrentId();
        append("\n%"+getId()+" = load i32,i32* "+vfinish.getReg());
        int idloadfinish=getCurrentId();
        if(d)   append("\n%"+getId()+" = icmp sle i32 %"+idload+",%"+idloadfinish);
        else    append("\n%"+getId()+" = icmp slt i32 %"+idload+",%"+idloadfinish);
        append("\nbr i1 %"+getCurrentId()+", label %for.body."+currFor+", label %for.exit."+currFor);
        append("\nfor.body."+currFor+":");
    }
    if(!inConditional)  inConditional=true;
    forloops.add(currFor);
    RESULT=currFor;
:} GO CONDSTMS GC {:
    Value v=getValue(index).value;
    append("\nbr label %for.inc."+RESULT);
    append("\nfor.inc."+RESULT+":");
    append("\n%"+getId()+" = load i32,i32* "+v.getReg());
    int k=getCurrentId();
    append("\n%"+getId()+" = add nsw i32 %"+k+",1");
    append("\nstore i32 %"+getCurrentId()+",i32* "+v.getReg());
    append("\nbr label %for.cond."+RESULT);
    append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:} | 
FOR ID:index IN ID:start DOTRANGE:d INTVAL:finish {:
    scopes.add(new Scope());
    int currFor=currentFor++;
    Tuple tstart=getValue(start);
    Value vstart=null;
    if(tstart!=null){
        if(tstart.value.initialized && tstart.value.irDec().equals("i32"))    vstart=tstart.value;
    }
    append("\nbr label %for.init."+currFor);
    append("\nfor.init."+currFor+":");
    append("\n%"+getId()+" = alloca i32, align 4");
    int indexId=getCurrentId();
    Value v=new Value(32);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    if(vstart!=null){
        append("\n%"+getId()+"= load i32,i32* "+vstart.getReg());
        append("\nstore i32 %"+getCurrentId()+",i32* %"+indexId);
        append("\nbr label %for.cond."+currFor);
        append("\nfor.cond."+currFor+":");
        append("\n%"+getId()+" = load i32,i32* %"+indexId);
        int idload=getCurrentId();
        if(d)   append("\n%"+getId()+" = icmp sle i32 %"+idload+","+finish);
        else    append("\n%"+getId()+" = icmp slt i32 %"+idload+","+finish);
        append("\nbr i1 %"+getCurrentId()+", label %for.body."+currFor+", label %for.exit."+currFor);
        append("\nfor.body."+currFor+":");
    }
    if(!inConditional)  inConditional=true;
    forloops.add(currFor);
    RESULT=currFor;
:} GO CONDSTMS GC {:
    Value v=getValue(index).value;
    append("\nbr label %for.inc."+RESULT);
    append("\nfor.inc."+RESULT+":");
    append("\n%"+getId()+" = load i32,i32* "+v.getReg());
    int k=getCurrentId();
    append("\n%"+getId()+" = add nsw i32 %"+k+",1");
    append("\nstore i32 %"+getCurrentId()+",i32* "+v.getReg());
    append("\nbr label %for.cond."+RESULT);
    append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:} | FOR ID:index IN INTVAL:start DOTRANGE:d ID:finish {:
    scopes.add(new Scope());
    int currFor=currentFor++;
    append("\nbr label %for.init."+currFor);
    append("\nfor.init."+currFor+":");
    append("\n%"+getId()+" = alloca i32, align 4");
    int indexId=getCurrentId();
    Value v=new Value(32);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    Tuple tfinish=getValue(finish);
    Value vfinish=null;
    if(tfinish!=null){
        if(tfinish.value.initialized && tfinish.value.irDec().equals("i32"))    vfinish=tfinish.value;
    }
    append("\nstore i32 "+start+",i32* %"+indexId);
    append("\nbr label %for.cond."+currFor);
    append("\nfor.cond."+currFor+":");
    append("\n%"+getId()+" = load i32,i32* %"+indexId);
    int idload=getCurrentId();
    if(vfinish!=null){
        append("\n%"+getId()+" = load i32,i32* "+vfinish.getReg());
        int idloadfinish=getCurrentId();
        if(d)   append("\n%"+getId()+" = icmp sle i32 %"+idload+",%"+idloadfinish);
        else    append("\n%"+getId()+" = icmp slt i32 %"+idload+",%"+idloadfinish);
    }
    append("\nbr i1 %"+getCurrentId()+", label %for.body."+currFor+", label %for.exit."+currFor);
    append("\nfor.body."+currFor+":");
    if(!inConditional)  inConditional=true;
    forloops.add(currFor);
    RESULT=currFor;
:} GO CONDSTMS GC {:
    Value v=getValue(index).value;
    append("\nbr label %for.inc."+RESULT);
    append("\nfor.inc."+RESULT+":");
    append("\n%"+getId()+" = load i32,i32* "+v.getReg());
    int k=getCurrentId();
    append("\n%"+getId()+" = add nsw i32 %"+k+",1");
    append("\nstore i32 %"+getCurrentId()+",i32* "+v.getReg());
    append("\nbr label %for.cond."+RESULT);
    append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:} ;


COND::= COND:a AND COND:b {:
    append("\n%"+getId()+" = and i1 "+a.getReg()+","+b.getReg());
    int andreg=getCurrentId();
    append("\n%"+getId()+"=  icmp eq i1 %"+andreg+",1");
    a.setReg(getCurrentId());
    RESULT=a;
:}| COND:a OR COND:b {:
    append("\n%"+getId()+" = or i1 "+a.getReg()+","+b.getReg());
    int andreg=getCurrentId();
    append("\n%"+getId()+"= icmp eq i1 %"+andreg+",1");
    a.setReg(getCurrentId());
    RESULT=a;
:}| NOT COND:a {:
    append("\n%"+getId()+"= icmp eq i1 "+a.getReg()+",0");
    a.setReg(getCurrentId());
    RESULT=a;
:} | CONDATTR:a {:
    if(!a.type.equals("i1")){
        if(a.type.equals("double"))  append("\n%"+getId()+"= fcmp ne "+a.type+" "+a.getReg()+",0");
        else    append("\n%"+getId()+"= icmp ne "+a.type+" "+a.getReg()+",0");
        RESULT=new Attribute("i1",getCurrentId());
    }
    else    RESULT=a;
:} | BO COND:a BC {: RESULT=a;
:};

CONDATTR::= EXP:a CONDOP:cond EXP:b {:
    if(!b.type.equals("double"))  append("\n%"+getId()+"= icmp "+getCondIrOp(cond,true)+" "+a.type+" "+a.getReg()+","+b.getReg());
    else append("\n%"+getId()+"= fcmp "+getCondIrOp(cond,false)+" "+a.type+" "+a.getReg()+","+b.getReg());
    RESULT=new Attribute("i1",getCurrentId());
:}| EXP:a {:RESULT=a;:};

CONDOP::= LESS {:RESULT=operations.LESS;:} | GREATER {:RESULT=operations.GRT;:} | LESSEQ {:RESULT=operations.LSE;:} | GREATEREQ {:RESULT=operations.GRE;:} | EQUAL {:RESULT=operations.EQ;:};

//function declaration

FUNCTION::=FUNCDef:f GO FSTMTS GC {:
    if(!f.returned){
        if(f.retType.equals("void"))    f.functionOutput.append("\nret void");
        else{
            errorBuffer.append("\nDidn't have a return statement and function isn't of type void");
            errors++;
        }
    }
    outputBuffer.append("{"+f.functionOutput+"\n}");
    inFunction=false;
    functionName=null;
    scopes.remove(scopes.size()-1);
:};

FUNCDef::=FUNC ID:name {:
    inFunction=true;
    functionName=name;
    Function f=new Function(name);
    functions.put(name,f);
:} BO PARlist:l BC RETVAL:r{:
    Function f=functions.get(name);
    outputBuffer.append("\ndefine "+r+" @"+name+" ("+l.stream().map(e->e.type.irDec()+" %"+e.name).collect(Collectors.joining(","))+")");
    f.setPars(l);
    f.setRet(r);
    f.scope=new Scope();
    scopes.add(f.scope);
    if(name.equals("main")) f.functionOutput.append("\ncall void () @globalinit()");
    l.stream().filter(e->!e.arrDim).forEach(e->{
        if(!e.type.inoutNeedsDeref()){
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec());
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.functionOutput.append("\nstore "+e.type.irDec()+" %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            if(e.type.inoutPar) f.scope.variables.put(e.name,v);
            else    f.scope.constants.put(e.name,v);
        }
        else{
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec());
            int reg=f.regId;
            f.functionOutput.append("\nstore "+e.type.irDec()+" %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            f.functionOutput.append("\n%"+(++f.regId)+" = load "+e.type.irDec()+","+e.type.irDec()+"* %"+reg);
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.scope.variables.put(e.name,v);
        }
    });
    RESULT=f;
:};

RETVAL::=ARROW T:t {:RESULT=t.irDec();:}| {:RESULT="void";:};

PARlist::= PARlist:l C PAR:p {:
    l.add(p);
    if(p.type.array){
        int dim=p.type.dimensions.size();
        for(int i=0;i<dim-1;i++){
            Value x=new Value(32);
            x.setInout(false);
            x.initialized=true;
            Parameter pfor=new Parameter(x,"dim."+functions.get(functionName).arrayNum+"."+i);
            pfor.setArrayDim();
            l.add(pfor);
            p.type.addFunctionDimension("dim."+functions.get(functionName).arrayNum+"."+i);
        }
        if(dim>1) functions.get(functionName).arrayNum++;
    }
    RESULT=l;
:}| PAR:p {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    l.add(p);
    if(p.type.array){
        int dim=p.type.dimensions.size();
        for(int i=0;i<dim-1;i++){
            Value x=new Value(32);
            x.setInout(false);
            x.initialized=true;
            Parameter pfor=new Parameter(x,"dim."+functions.get(functionName).arrayNum+"."+i);
            pfor.setArrayDim();
            l.add(pfor);
            p.type.addFunctionDimension("dim."+functions.get(functionName).arrayNum+"."+i);
        }
        if(dim>1) functions.get(functionName).arrayNum++;
    }
    RESULT=l;
:} | {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    RESULT=l;
:};

PAR::= ID:label ID:name FTYPE:f {:RESULT=new Parameter(f,name,label);:}| ID:name FTYPE:f {:RESULT=new Parameter(f,name,name);:}| USCORE ID:name FTYPE:f{:RESULT=new Parameter(f,name);:};
 
FTYPE::= COL INOUTF:i TList:t {:t.setInout(i);t.initialized=true;RESULT=t;:};

INOUTF::=INOUT {:RESULT=true;:} | {:RESULT=false;:};

FSTMTS::= FSTMTS FSTM | ;

FSTM::=IFCOMPLETEBLOCK | WHILECOND | FORCOND | ASS | PROC | DEC | RET ;

RET::= RETURN EXP:e {:
    Function f=functions.get(functionName);
    if(f.retType.equals(e.type)){
        f.functionOutput.append("\nret "+e.type+" "+e.getReg());
        f.returned=true;
        getId();
    }
    else{
        errorBuffer.append("\nReturning a type that doesn't match with the return type of the function");
        errors++;
    }
:} | RETURN {:
    Function f=functions.get(functionName);
    if(!f.retType.equals("void")){
        errorBuffer.append("\nReturning nothing from a non void function");
        errors++;
    }
    else{
        f.functionOutput.append("\nret void");
        f.returned=true;
        getId();
    }
:};