import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Object;
import java.util.stream.Collectors ;
import java.lang.Math.*;

parser code {:
    public enum operations{
        ADD,
        MUL,
        DIV,
        SUB,
        LESS,
        GRT,
        LSE,
        GRE,
        EQ
    };
    public class Scope{
        public HashMap<String,Value> variables;
        public HashMap<String,Value> constants;
        public Scope(){
            this.variables=new HashMap<String,Value>();
            this.constants=new HashMap<String,Value>();
        }
    }
    public class FValue{
        public boolean inout;
        public Value value;
        public FValue(boolean inout,Value value){
            this.inout=inout;
            this.value=value;
        }
    }
    public class Parameter{
        public boolean inout;
        public boolean argLabel;
        public String name;
        public String label;
        public Value type;
        public Parameter(boolean inout,String name,Value type){
            this.inout=inout;
            this.argLabel=false;
            this.name=name;
            this.type=type;
        }
        public Parameter(boolean inout,String name,Value type,String label){
            this.inout=inout;
            this.argLabel=true;
            this.name=name;
            this.type=type;
            this.label=label;
        }
    }
    public class ClassType{
        public int sizeClass;
        public ArrayList<Function> functions;
        public Scope scope;
        public ClassType(int size,ArrayList<Function> funcs,Scope props){
            this.sizeClass=size;
            this.functions=funcs;
            this.scope=scope;
        }
    }
    public class Function{
        public String name;
        public String retType;
        public ArrayList<Parameter> pars;
        public StringBuffer functionOutput=new StringBuffer();
        public Scope scope;
        public int regId=0;
        public boolean returned;
        public Function(String name,String retType,ArrayList<Parameter> pars){
            this.name=name;
            this.retType=retType;
            this.pars=pars;
            this.returned=false;
        }
        public String irDec(){
            return retType+" ("+pars.stream().map(e->e.type.irDec()).collect(Collectors.joining(","))+") @"+name;
        }
    }
    /*public class Variable{
        public String name;
        public boolean initialized;
        public String type;
        public boolean pointer;
        public boolean funcParameter;
        public ArrayList<String> funcDimArr;
        public int addrReg;
        public String irDec(){
            return type+(pointer?"*":"");
        }
        public Variable(String name,boolean costant,String type){
            this.name=name;
            this.initialized=initialized;
            this.type=type;
        }
    }*/
    public class Attribute{
        public String type;
        public int regId;
        public boolean immediate;
        public Object immediateValue;
        public Attribute(String type,int regId){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
        }
        public Attribute(Object immediateValue,String type){
            this.immediate=true;
            this.immediateValue=immediateValue;
            this.type=type;
        }
        public void setReg(int regId){
            this.regId=regId;
        }
        public String getReg(){
            if(this.immediate) return this.immediateValue.toString();
            else    return "%"+this.regId;
        }
    }
    public class ArrayDec{
        public String type;
        public ArrayList<Attribute> value;
        public ArrayList<ArrayDec> arraysInside;
        public boolean closed;
        public boolean last;
        public ArrayDec(String type,ArrayList<Attribute> value,boolean closed){
            this.type=type;
            this.value=value;
            this.closed=closed;
            this.last=true;
        }
        public ArrayDec(ArrayList<ArrayDec> arraysInside,String type,boolean closed){
            this.type=type;
            this.arraysInside=arraysInside;
            this.closed=closed;
            this.last=false;
        }
        public void close(){
            this.type="["+arraysInside.size()+" x "+this.type+"]";
            this.closed=true;
        }
        public int level(){
            if(this.last) return 1;
            else return this.arraysInside.get(0).level();
        }
        public String printValue(){
            StringBuffer res=new StringBuffer();
            res.append("[");
            if(this.last){
                for(int i=0;i<value.size();i++){
                    res.append(value.get(i).immediateValue);
                    if(i!=value.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
            else{
                for(int i=0;i<arraysInside.size();i++){
                    res.append(arraysInside.get(i).printValue());
                    if(i!=arraysInside.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
        }
    }
    public class Value{
        public boolean integer;
        public boolean pointer;
        public boolean array;
        public int sizeInt=0;
        public int sizeArr=0;
        public ClassType classType;
        public Object value;
        public int pointerAllocated=(-1);
        public boolean global=false;
        public String globalName;
        public String constructorType="";
        public Value(Value o){
            this.integer=o.integer;
            this.pointer=o.pointer;
            this.array=o.array;
            this.sizeInt=o.sizeInt;
            this.sizeArr=o.sizeArr;
            this.classType=o.classType;
            this.value=o.value;
            this.pointerAllocated=o.pointerAllocated;
            this.global=o.global;
        }
        public Value(String type){
            this.integer=false;
            this.pointer=false;
            this.array=true;
            this.global=false;
            this.constructorType=type;
        }
        public Value(int intSize,boolean pointer){
            this.integer=true;
            this.sizeInt=intSize;
            this.pointer=pointer;
            this.array=false;
        }
        public Value(int intSize,boolean pointer,Object value){
            this.integer=true;
            this.sizeInt=intSize;
            this.pointer=pointer;
            this.value=value;
            this.array=false;
        }
        public Value(boolean pointer){
            this.integer=false;
            this.array=false;
            this.pointer=pointer;
        }
        public Value(boolean pointer,Object value){
            this.integer=false;
            this.array=false;
            this.pointer=pointer;
            this.value=value;
        }
        public Value(ClassType obj){
            this.classType=obj;
            this.integer=false;
            this.array=false;
            this.pointer=false;
        }
        public void addArrLevel(){
            this.array=true;
            this.sizeArr++;
        }
        public boolean equal(Value o){
            boolean a= this.integer==o.integer && this.pointer==o.pointer && this.array==o.array;
            if(!a) return a;
            if(this.integer){
                a=this.sizeInt==o.sizeInt;
                if(!a) return a;
            }
            if(this.array){
                a=this.sizeArr==o.sizeArr;
                if(!a) return a;
            }
            return true;
        }
        public void setValue(Object val){
            this.value=val;
        }
        public void setReg(int regId){
            if(this.pointerAllocated==-1) this.pointerAllocated=regId; 
        }
        public void setReg(String name){
            this.global=true;
            this.globalName=name;
        }
        public String getReg(){
            if(this.global) return "@"+this.globalName;
            else return "%"+this.pointerAllocated;
        }
        public String irDec(){
            if(this.constructorType.length()>0) return this.constructorType;
            StringBuffer type=new StringBuffer();
            if(integer) type.append("i"+sizeInt);
            else type.append("double");
            if(pointer) type.append("*");
            if(array){
                StringBuffer res=new StringBuffer();
                for(int i=0;i<this.sizeArr;i++){
                    res.append("[10 x ");
                    if(i==this.sizeArr-1){
                        res.append(type.toString());
                        for(int j=0;j<this.sizeArr;j++) res.append("]");
                    }
                }
                return res.toString();
            }
            else return type.toString();
        }
        @Override
        public String toString() {
            return this.irDec() +" with reg:"+this.getReg();
        }
    }
    public Scope globalScope=new Scope();
    public ArrayList<Scope> scopes=new ArrayList<Scope>();
    public StringBuffer outputBuffer=new StringBuffer();
    public StringBuffer errorBuffer=new StringBuffer();
    public StringBuffer globalBuffer=new StringBuffer();
    public boolean errors=false;
    public HashMap<String,ClassType> classes=new HashMap<String,ClassType>();
    public HashMap<String,Function> functions=new HashMap<String,Function>();
    public int regid=0;
    public int stringIndex=(-1);
    public boolean inFunction=false;
    public String functionName;
    public int currentIf=0;
    public int currentFor=0;
    public boolean inConditional=false;
    public String getIrOp(operations op,String type){
        boolean integer=type.equals("i32");
        System.out.println("Inside getirop with type: "+type+" and operator : "+op+", is it integer? "+integer);
        if(op==operations.ADD){
            if(integer) return "add nsw";
            else return "fadd nsw";
        }
        else if(op==operations.SUB){
            if(integer) return "sub";
            else return "fsub";
        }
        else if(op==operations.MUL){
            if(integer) return "mul";
            else return "fmul";
        }
        else if(op==operations.DIV){
            if(integer) return "sdiv";
            else return "fdiv";
        }
        else return "NOT SUPPORTED";
    }
    public String getVarIrDec(String var){
        System.out.println("Inside getvarirdec with: "+var+" and infunction? "+inFunction);
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)) return scope.variables.get(var).irDec();
            else if(scope.constants.containsKey(var)) return scope.constants.get(var).irDec();
        }
        return "ERROR";
    }
    public String getRegVar(String var){
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)) return scope.variables.get(var).getReg();
            else if(scope.constants.containsKey(var)) return scope.constants.get(var).getReg();
        }
        return "ERROR";
    }
    public void storeRow(int i,ArrayDec a){
        Function f=functions.get(functionName);
        if(a.last){
            for(int j=0;j<a.value.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                f.functionOutput.append("\nstore "+a.value.get(j).type+" "+a.value.get(j).getReg()+","+a.value.get(j).type+"* %"+f.regId);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                storeRow(f.regId,a.arraysInside.get(j));
            }
        }
    }
    public String getCondIrOp(operations cond,boolean integer){
        if(cond==operations.LESS){
            if(integer) return "slt";
            else return "olt";
        }
        else if(cond==operations.GRT){
            if(integer) return "sgt";
            else return "ogt";
        }
        else if(cond==operations.LSE){
            if(integer) return "sle";
            else return "ole";
        }
        else if(cond==operations.GRE){
            if(integer) return "sge";
            else return "oge";
        }
        else if(cond==operations.EQ){
            if(integer) return "eq";
            else return "oeq";
        }
        else return "ERROR";
    }
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error, BUT BEFORE HERE WAS THE MAIN CONTENT: "+functions.get("main").functionOutput.toString()+"\n\n");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
:};

action code{:
    
:};

terminal LET,VAR,DOUBLEVAL,INTVAL;
terminal String ID,STRINGVAL,STRINGVALS,STRINGVALI,STRINGVALE;
terminal C,EQ,COL,BO,BC,GO,GC,ARROW;
terminal STRING,DOUBLE,INT,FUNC,USCORE;
terminal PLUS,MINUS,DIV,MUL;
terminal LESS,GREATER,LESSEQ,GREATEREQ,AND,OR,EQUAL,NOT;
terminal ELIF,ELSE,IF,FOR,IN,WHILE,DOT;
terminal QO,QC,INOUT,CLASS;
terminal PRINT,RETURN;
terminal uminus;

non terminal PROG,DEC,IDINITlist,INIT;
non terminal ASS,STMS,STM,FUNCTION,FSTMTS;
non terminal WHILECOND,FORCOND;
non terminal ATTRL;
non terminal CLASSDEF,CSTMTS;
non terminal ArrayList<String> IDlist;
non terminal Value TYPE;
non terminal Attribute VAL;
non terminal Value TList,T;
non terminal operations OP;
non terminal Attribute ATTR,EXP,PROC;
non terminal Parameter PAR;
non terminal ArrayList<Parameter> PARlist;
non terminal Attribute CPAR;
non terminal ArrayList<Attribute> CPARlist;
non terminal String RETVAL;
non terminal FValue FTYPE;
non terminal Boolean INOUTF;
non terminal Integer STR;
non terminal Integer STRINGVALINTERP;
non terminal Function FUNCDef;
non terminal ArrayList<Integer> PRINTPARList;
non terminal Attribute  IDARR;
non terminal ArrayDec ARRVALE,ARRVAL;
non terminal ArrayList<Attribute> EXPL;
non terminal Integer IFCONDDEC;
non terminal Attribute IFCC,IFCOND;
non terminal IFCOMPLETEBLOCK;
non terminal Attribute CONDATTR,COND;
non terminal operations CONDOP;
non terminal Integer WHILEDEF;
non terminal RET;

precedence left PLUS,MINUS,OR;
precedence left MUL,DIV,AND;
precedence left uminus;

start with PROG;

PROG::= {:scopes.add(globalScope);:} STMS {:System.out.println("At the end the global buffer has:\n"+globalBuffer+"\nand theoutput buffer has:\n"+outputBuffer+"\n");:};

//declarations of variables

DEC::= LET IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        globalBuffer.append("\n@"+a+"= alloca "+t.irDec()+",align 4");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
    else{
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+"= alloca "+t.irDec()+",align 4");
        Value v=new Value(t);
        v.setReg(f.regId);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
});:} | VAR IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        globalBuffer.append("\n@"+a+"= alloca "+t.irDec()+",align 4");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
    else{
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+"= alloca "+t.irDec()+",align 4");
        Value v=new Value(t);
        v.setReg(f.regId);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
});:} | LET IDINITlist | VAR IDINITlist;

IDlist::= IDlist:l C ID:x {: ArrayList<String> arr= new ArrayList<String>(l);
                            arr.add(x);
                            RESULT=arr;:}| ID:x{:ArrayList<String> arr= new ArrayList<String>();
                            arr.add(x);
                            RESULT=arr;:};

IDINITlist::= IDINITlist C INIT | INIT;

INIT::= ID EQ VAL | ID:i EQ ARRVALE:l {:
    Function f=functions.get(functionName);
    System.out.println("Arrived at def of "+i+" that is arrval with type: "+l.type);
    f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+l.type);
    storeRow(f.regId,l);
    Value v=new Value(l.type);
    v.setReg(f.regId);
    scopes.get(scopes.size()-1).variables.put(i,v);
:} ;

TYPE::= COL TList:t {:RESULT=t;:}| COL TList:t EQ VAL:v {:
    /*if(t.equal(v)) RESULT=t;
    else System.out.println("\tPARSER:: ERROR FOUND ON DECLARATION;");*/
    RESULT=t;
:} | COL TList:t EQ ARRVAL;

VAL::= DOUBLEVAL:v {:RESULT=new Attribute(v,"double");:}| INTVAL:v {:RESULT=new Attribute(v,"i32");:}| STR:v {:RESULT=new Attribute(v,"[200 x i8]");:};

STR::= STRINGVAL:s {:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    int id;
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds ["+s.length()+" x i8], ["+s.length()+" x i8]* @.str."+stringIndex+" , i32 0, i32 0");
        id=f.regId;
    }
    else{
        outputBuffer.append("\n%"+(++regid)+" = getelementptr inbounds ["+s.length()+" x i8], ["+s.length()+" x i8]* @.str."+stringIndex+" , i32 0, i32 0");
        id=regid;
    }
    RESULT=id;
:}| STRINGVALS:s STRINGVALINTERP:i STRINGVALE:e{:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(e.length()+1)+" x i8] c\""+e+"\\00\"");
    int stringArrPointer;
    int stringGepPointer;
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+" = alloca [200 x i8], align 1");
        stringArrPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds [200 x i8], [200 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = call i8* (i8*,i8*) @strcpy(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+(stringIndex-1)+", i32 0, i32 0))");
        f.functionOutput.append("\n%"+(++f.regId)+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* %"+i+")");
        f.functionOutput.append("\n%"+(++f.regId)+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(e.length()+1)+" x i8], ["+(e.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0))");
    }
    else{
        outputBuffer.append("\n%"+(++regid)+" = alloca [200 x i8], align 1");
        stringArrPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = getelementptr inbounds [200 x i8], [200 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = call i8* (i8*,i8*) @strcpy(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+(stringIndex-1)+", i32 0, i32 0))");
        outputBuffer.append("\n%"+(++regid)+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* %"+i+")");
        outputBuffer.append("\n%"+(++regid)+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(e.length()+1)+" x i8], ["+(e.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0))");
    }
    RESULT=stringGepPointer;
:};

STRINGVALINTERP::= STRINGVALINTERP:i EXP:e {:
    int stringArrPointer;
    int stringGepPointer;
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+" = alloca [20 x i8], align 1");
        stringArrPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
        f.functionOutput.append("\n%"+(++f.regId)+" = call i8* (i8*,i8*) @strcat(i8* %"+i+",i8* %"+(stringGepPointer)+")");
    }
    else{
        outputBuffer.append("\n%"+(++regid)+" = alloca [20 x i8], align 1");
        stringArrPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
        outputBuffer.append("\n%"+(++regid)+" = call i8* (i8*,i8*) @strcat(i8* %"+i+",i8* %"+(stringGepPointer)+")");
    }
    RESULT=i;
:}| EXP:e STRINGVALI:s {:
    int stringArrPointer;
    int stringGepPointer;
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+" = alloca [150 x i8], align 1");
        stringArrPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds [150 x i8], [150 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
        f.functionOutput.append("\n%"+(++f.regId)+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0))");
    }
    else{
        outputBuffer.append("\n%"+(++regid)+" = alloca [150 x i8], align 1");
        stringArrPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = getelementptr inbounds [150 x i8], [150 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
        outputBuffer.append("\n%"+(++regid)+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8] ["+(s.length()+1)+" x i8]* @"+stringIndex+" , i32 0, i32 0)");
    }
    RESULT=stringGepPointer;
:}| EXP:e {:
    int stringArrPointer;
    int stringGepPointer;
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+" = alloca [20 x i8], align 1");
        stringArrPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=f.regId;
        f.functionOutput.append("\n%"+(++f.regId)+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
    }
    else{
        outputBuffer.append("\n%"+(++regid)+" = alloca [20 x i8], align 1");
        stringArrPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
        stringGepPointer=regid;
        outputBuffer.append("\n%"+(++regid)+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
    }
    RESULT=stringGepPointer;
:};

ARRVALE::= QO ARRVALE:l QC {:
    System.out.println("Arrived at QO ARRVALE QC with type : "+l.type+" , and l has "+l.arraysInside.size()+" arrays inside, l is closed?"+l.closed);
    l.close();
    System.out.println("NOw type is : "+l.type);
    RESULT=l;
    System.out.println("res value: "+RESULT.printValue());
:}| ARRVALE:l C ARRVALE:a {:
    /*int alevel=a.level();
    int llevel=l.level();
    System.out.println("Arrived at ARRVALE C ARRVAL with l level: "+llevel+" , and a level: "+alevel);*/
    System.out.println("l value: "+l.printValue());
    System.out.println("a value: "+a.printValue());
    if(!l.last){
        System.out.println("L has "+l.arraysInside.size()+" arrays inside");
    }
    if(!a.last){
        System.out.println("a has "+a.arraysInside.size()+" arrays inside");
    }
    if(l.closed && a.closed){
        ArrayList<ArrayDec> arr=new ArrayList<ArrayDec>();
        arr.add(l);
        arr.add(a);
        RESULT=new ArrayDec(arr,a.type,false);
        System.out.println("Both are closed so CREATE NEW ARRDEC ENGLOBING THAT IS NOT CLOSED,"+RESULT);
        System.out.println("NOw result has type : "+RESULT.type+" and is closed? "+RESULT.closed+", and has "+RESULT.arraysInside.size()+" arrays inside");
        System.out.println("res value: "+RESULT.printValue());
    }
    else{
        a.arraysInside.add(0,l);
        RESULT=a;
        System.out.println("ONE IS OPEN SO WE JUST NEED TO ADD TO THE OLD ENGLOBER "+RESULT);
        System.out.println("NOw result has type : "+RESULT.type+" and is closed? "+RESULT.closed+", and has "+RESULT.arraysInside.size()+" arrays inside");
        System.out.println("res value: "+RESULT.printValue());

    }
:}| ARRVAL:a {:
    //ArrayList<Attribute> l=new ArrayList<Attribute>();
    //l.add(a);
    //RESULT=l;
    System.out.println("REDUCED ARRVAL INTO ARRVALE: "+a.printValue());
    RESULT=a;
:};

ARRVAL::= QO EXPL:l QC {:
    System.out.println("Arrived at QO EXPL QC with type: "+l.get(0).type);
    System.out.println("NEw type: "+"["+l.size()+" x "+l.get(0).type+"]");
    RESULT=new ArrayDec("["+l.size()+" x "+l.get(0).type+"]",l,true);
:};

EXPL::= EXPL:l C EXP:e {:
    l.add(e);
    RESULT=l;
:} | EXP:e {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    l.add(e);
    RESULT=l;
:} | ;

TList::= QO TList:t QC {:
    t.addArrLevel();
    RESULT=t;
:}| T:t {:RESULT=t;:};

T::=STRING {:RESULT=new Value(8,true);:}| DOUBLE {:RESULT=new Value(false);:}| INT{:RESULT=new Value(32,false);:} | ID:name {:
    boolean cont=false;
    for (String key : classes.keySet()) {
        if (name.contains(key)) {
            cont=true;
            break;
        }
    }
    if(!cont){
        errors=true;
        errorBuffer.append("Tried to assign a non specified type to a variable");
    }
    else    RESULT=new Value(classes.get(name));
:};

//assignment

ASS::= ID:a EQ EXP:e {:
    String type=getVarIrDec(a);
    if(!e.type.equals(type)){
        System.out.println("\t\t\tERRORRRRR IN ASSINGMENT");
    }
    System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
    if(inFunction)  functions.get(functionName).functionOutput.append("\nstore "+type+" "+e.getReg()+","+type+"* "+getRegVar(a));
    else    outputBuffer.append("\nstore "+type+" "+e.getReg()+","+type+"* "+getRegVar(a));
:} | IDARR:a EQ EXP:e {:
    functions.get(functionName).functionOutput.append("\nstore "+e.type+" "+e.getReg()+","+a.type+"* "+a.getReg());
:} ;

EXP::= EXP:e PLUS EXP:a {:
    int id;
    /*if(!e.type.equals(a.type)){
        System.out.println("Error in EXP because of type, e has type: "+e.type+" , while a has type: "+a.type);
        errorBuffer.append("Error in exp");
    }
    else{*/
    System.out.println("In exp with exp a of type: "+e.type+" and reg: "+e.getReg()+" , and attr b of type: "+a.type+" and reg: "+a.getReg());
        if(inFunction){
            Function f=functions.get(functionName);
            f.functionOutput.append("\n%"+(++f.regId)+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" ");
            if(e.immediate) f.functionOutput.append(e.immediateValue);
            else f.functionOutput.append(e.getReg());
            f.functionOutput.append(",");
            if(a.immediate) f.functionOutput.append(a.immediateValue);
            else f.functionOutput.append(a.getReg());
            id=f.regId;
        }
        else{
            outputBuffer.append("\n%"+(++regid)+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" ");
            if(e.immediate) outputBuffer.append(e.immediateValue);
            else outputBuffer.append(e.getReg());
            outputBuffer.append(",");
            if(a.immediate) outputBuffer.append(a.immediateValue);
            else outputBuffer.append(a.getReg());
            id=regid;
        }
    //}
    RESULT=new Attribute(e.type,id);
:}| ATTR:a {:
    RESULT=a;
:}| EXP:e MINUS EXP:a {:
    int id;
    /*if(!e.type.equals(a.type)){
        System.out.println("Error in EXP because of type, e has type: "+e.type+" , while a has type: "+a.type);
        errorBuffer.append("Error in exp");
    }
    else{*/
    System.out.println("In exp with exp a of type: "+e.type+" and reg: "+e.getReg()+" , and attr b of type: "+a.type+" and reg: "+a.getReg());
        if(inFunction){
            Function f=functions.get(functionName);
            f.functionOutput.append("\n%"+(++f.regId)+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" ");
            if(e.immediate) f.functionOutput.append(e.immediateValue);
            else f.functionOutput.append(e.getReg());
            f.functionOutput.append(",");
            if(a.immediate) f.functionOutput.append(a.immediateValue);
            else f.functionOutput.append(a.getReg());
            id=f.regId;
        }
        else{
            outputBuffer.append("\n%"+(++regid)+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" ");
            if(e.immediate) outputBuffer.append(e.immediateValue);
            else outputBuffer.append(e.getReg());
            outputBuffer.append(",");
            if(a.immediate) outputBuffer.append(a.immediateValue);
            else outputBuffer.append(a.getReg());
            id=regid;
        }
    //}
    RESULT=new Attribute(e.type,id);
:} | EXP:e MUL EXP:a {:
    int id;
    /*if(!e.type.equals(a.type)){
        System.out.println("Error in EXP because of type, e has type: "+e.type+" , while a has type: "+a.type);
        errorBuffer.append("Error in exp");
    }
    else{*/
    System.out.println("In exp with exp a of type: "+e.type+" and reg: "+e.getReg()+" , and attr b of type: "+a.type+" and reg: "+a.getReg());
        if(inFunction){
            Function f=functions.get(functionName);
            f.functionOutput.append("\n%"+(++f.regId)+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" ");
            if(e.immediate) f.functionOutput.append(e.immediateValue);
            else f.functionOutput.append(e.getReg());
            f.functionOutput.append(",");
            if(a.immediate) f.functionOutput.append(a.immediateValue);
            else f.functionOutput.append(a.getReg());
            id=f.regId;
        }
        else{
            outputBuffer.append("\n%"+(++regid)+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" ");
            if(e.immediate) outputBuffer.append(e.immediateValue);
            else outputBuffer.append(e.getReg());
            outputBuffer.append(",");
            if(a.immediate) outputBuffer.append(a.immediateValue);
            else outputBuffer.append(a.getReg());
            id=regid;
        }
    //}
    RESULT=new Attribute(e.type,id);
:} | EXP:e DIV EXP:a {:
    int id;
    /*if(!e.type.equals(a.type)){
        System.out.println("Error in EXP because of type, e has type: "+e.type+" , while a has type: "+a.type);
        errorBuffer.append("Error in exp");
    }
    else{*/
    System.out.println("In exp with exp a of type: "+e.type+" and reg: "+e.getReg()+" , and attr b of type: "+a.type+" and reg: "+a.getReg());
        if(inFunction){
            Function f=functions.get(functionName);
            f.functionOutput.append("\n%"+(++f.regId)+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" ");
            if(e.immediate) f.functionOutput.append(e.immediateValue);
            else f.functionOutput.append(e.getReg());
            f.functionOutput.append(",");
            if(a.immediate) f.functionOutput.append(a.immediateValue);
            else f.functionOutput.append(a.getReg());
            id=f.regId;
        }
        else{
            outputBuffer.append("\n%"+(++regid)+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" ");
            if(e.immediate) outputBuffer.append(e.immediateValue);
            else outputBuffer.append(e.getReg());
            outputBuffer.append(",");
            if(a.immediate) outputBuffer.append(a.immediateValue);
            else outputBuffer.append(a.getReg());
            id=regid;
        }
    //}
    RESULT=new Attribute(e.type,id);
:} | BO EXP:e BC {:RESULT=e;:}
| MINUS EXP:e {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\n%"+(++f.regId)+" = sub "+e.type+" 0,"+e.getReg());
    RESULT=new Attribute(e.type,f.regId);
:} %prec uminus;

ATTR::= PROC:p {:
    RESULT=p;
:} | ID:i {:
    String type=getVarIrDec(i);
    int id;
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+"= load "+type+","+type+"* "+getRegVar(i));
        id=f.regId;
    }
    else{
        outputBuffer.append("\n%"+(++regid)+"= load "+type+","+type+"* "+getRegVar(i));
        id=regid;
    }
    RESULT=new Attribute(type,id);
:} | VAL:v {:
    RESULT=v;
:} | IDARR:i {:
    int id;
    if(inFunction){
        Function f=functions.get(functionName);
        f.functionOutput.append("\n%"+(++f.regId)+"= load "+i.type+","+i.type+"* "+i.getReg());
        id=f.regId;
    }
    else{
        outputBuffer.append("\n%"+(++regid)+"= load "+i.type+","+i.type+"* "+i.getReg());
        id=regid;
    }
    RESULT=new Attribute(i.type,id);
:} ;

IDARR::= IDARR:i QO ATTR:a QC {:
    Function f=functions.get(functionName);
    String ir=i.type;
    System.out.println("ir of idarr is "+ir);
    f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+i.type+","+i.type+"* "+i.getReg()+", i32 0, i32 "+a.getReg());
    String subir=ir.substring(1,ir.length()-1);
    System.out.println("sub from 1 to lenght-1 is : "+subir);
    System.out.println("subir index of [: "+subir.indexOf("["));
    String newType;
    if(subir.indexOf("[")<0){
        System.out.println("subir index of x: "+subir.indexOf("x"));
        newType=subir.substring(subir.indexOf("x")+2,subir.length());
    }
    else newType=subir.substring(subir.indexOf("["),subir.length());
    System.out.println("new type is : "+newType );
    RESULT=new Attribute(newType,f.regId);
:} | ID:i QO ATTR:a QC {:
    Function f=functions.get(functionName);
    String ir=getVarIrDec(i);
    String reg=getRegVar(i);
    System.out.println("ir of "+i+" is "+ir);
    f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+ir+","+ir+"* "+reg+", i32 0, i32 "+a.getReg());
    String subir=ir.substring(1,ir.length()-1);
    System.out.println("sub from 1 to lenght-1 is : "+subir);
    System.out.println("subir index of [: "+subir.indexOf("["));
    String newType;
    if(subir.indexOf("[")<0){
        System.out.println("subir index of x: "+subir.indexOf("x"));
        newType=subir.substring(subir.indexOf("x")+2,subir.length());
    }
    else newType=subir.substring(subir.indexOf("["),subir.length());
    RESULT=new Attribute(newType,f.regId);
:} ;

OP::= PLUS {:RESULT=operations.ADD;:} | MINUS {:RESULT=operations.SUB;:} | DIV {:RESULT=operations.DIV;:} | MUL {:RESULT=operations.MUL;:};

//statements

STMS::= STMS STM | STM;

STM::=ASS | PROC | DEC | FUNCTION | IFCOMPLETEBLOCK | WHILECOND | FORCOND | CLASSDEF | RET;

PROC::= ID:name BO CPARlist:l BC {:
    Function f=functions.get(name);
    int id=0;
    if(f.retType.equals("void")){
        if(inFunction){
            Function o=functions.get(functionName);
            o.functionOutput.append("\ncall "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
        }
        else    outputBuffer.append("\ncall "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
    }
    else{
        if(inFunction){
            Function o=functions.get(functionName);
            o.functionOutput.append("\n%"+(++o.regId)+"=call "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
            id=o.regId;
        }
        else{
            outputBuffer.append("\n%"+(++regid)+"=call "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
            id=regid;
        }
    }
    RESULT=new Attribute(f.retType,id);
:} | PRINT BO PRINTPARList:l BC{:
    if(inFunction){
        Function f=functions.get(functionName);
        l.forEach(p->f.functionOutput.append("\n%"+(++f.regId)+" = call i32 (i8*, ...) @printf(i8* %"+p+")"));
        f.functionOutput.append("\n%"+(++f.regId)+" = call i32 (i8*, ...) @printf(i8* getelementptr inbounds([2 x i8], [2 x i8]* @.str.newline, i32 0, i32 0))");
    }
    else{
        l.forEach(p->outputBuffer.append("\n%"+(++regid)+" = call i32 (i8*, ...) @printf(i8* %"+p+")"));
        outputBuffer.append("\n%"+(++regid)+" = call i32 (i8*, ...) @printf(i8* getelementptr inbounds([2 x i8], [2 x i8]* @.str.newline, i32 0, i32 0))");
    }
:};

PRINTPARList::= PRINTPARList:l C STR:s {:
    l.add(s);
    RESULT=l;
:}| STR:s{:
    ArrayList<Integer> pointers=new ArrayList<Integer>();
    pointers.add(s);
    RESULT=pointers;
:};

CPARlist::= CPARlist:l C CPAR:p {:
    l.add(p);
    RESULT=l;
:} | CPAR:p {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    l.add(p);
    RESULT=l;
:};

CPAR::= ID:name COL EXP:e {:RESULT=e;:} | EXP:e {:RESULT=e;:} ;


//control loop blocks

IFCOMPLETEBLOCK::= IFCC:ifc {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    f.functionOutput.append("\nbr label %if.exit."+ifc.type+".0");
    f.functionOutput.append("\nif.exit."+ifc.type+".0:");
:} | IFCC:ifc ELSE {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO STMS GC {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr label %if.exit."+ifc.type+".0");
    f.functionOutput.append("\nif.exit."+ifc.type+".0:");
    scopes.remove(scopes.size()-1);
:};

IFCC::= IFCC:ifc ELIF {:
    functions.get(functionName).functionOutput.append("\nif.elif."+ifc.type+"."+ifc.regId+":");
:} COND:cond {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr i1 "+cond.getReg()+", label %if.body."+ifc.type+"."+ifc.regId+", label %if.elif."+ifc.type+"."+(ifc.regId+1));
    f.functionOutput.append("\nif.body."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO STMS GC {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr label %if.exit."+ifc.type+".0");
    ifc.setReg(ifc.regId+1);
    scopes.remove(scopes.size()-1);
    RESULT=ifc;
:} | IFCOND:ifc {:scopes.remove(scopes.size()-1);RESULT=ifc;:};

IFCOND::= IFCONDDEC:ifNum GO STMS GC {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr label %if.exit."+ifNum+".0");
    scopes.remove(scopes.size()-1);
    RESULT=new Attribute(""+ifNum,0);
:} | IFCONDDEC STM ;

IFCONDDEC::= IF COND:cond {:
    Function f=functions.get(functionName);
    int currIf=currentIf++;
    inConditional=true;
    f.functionOutput.append("\nbr i1 "+cond.getReg()+", label %if.body."+currIf+", label %if.elif."+currIf+".0");
    f.functionOutput.append("\nif.body."+currIf+":");
    scopes.add(new Scope());
    RESULT=currIf;
:};


WHILECOND::= WHILEDEF:wh COND:cond {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr i1 "+cond.getReg()+", label %for.body."+wh+", label %for.exit."+wh);
    f.functionOutput.append("\nfor.body."+wh+":");
    scopes.add(new Scope());
:} GO STMS GC {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr label %for.cond."+wh);
    f.functionOutput.append("\nfor.exit."+wh+":");
    scopes.remove(scopes.size()-1);
:};

WHILEDEF::= WHILE {:
    Function f=functions.get(functionName);
    int currWh=currentFor++;
    f.functionOutput.append("\nbr label %for.cond."+currWh);
    f.functionOutput.append("\nfor.cond."+currWh+":");
    RESULT=currWh;
:};

FORCOND::= FOR ID:index IN INTVAL:start DOT DOT DOT INTVAL:finish {:
    scopes.add(new Scope());
    Function f=functions.get(functionName);
    int currFor=currentFor++;
    f.functionOutput.append("\nbr label %for.init."+currFor);
    f.functionOutput.append("\nfor.init."+currFor+":");
    f.functionOutput.append("\n%"+(++f.regId)+" = alloca i32, align 4");
    int indexId=f.regId;
    Value v=new Value(32,false);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    f.functionOutput.append("\nstore i32 "+start+",i32* %"+indexId);
    f.functionOutput.append("\nbr label %for.cond."+currFor);
    f.functionOutput.append("\nfor.cond."+currFor+":");
    f.functionOutput.append("\n%"+(++f.regId)+" = load i32,i32* %"+indexId);
    int idload=f.regId;
    f.functionOutput.append("\n%"+(++f.regId)+" = icmp sle i32 %"+idload+","+finish);
    f.functionOutput.append("\nbr i1 %"+f.regId+", label %for.body."+currFor+", label %for.exit."+currFor);
    f.functionOutput.append("\nfor.body."+currFor+":");
    RESULT=currFor;
:} GO STMS GC {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\nbr label %for.inc."+RESULT);
    f.functionOutput.append("\nfor.inc."+RESULT+":");
    f.functionOutput.append("\n%"+(++f.regId)+" = load i32,i32* "+getRegVar(index));
    int k=f.regId;
    f.functionOutput.append("\n%"+(++f.regId)+" = add nsw i32 %"+k+",1");
    f.functionOutput.append("\nstore i32 %"+f.regId+",i32* "+getRegVar(index));
    f.functionOutput.append("\nbr label %for.cond."+RESULT+":");
    f.functionOutput.append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
:} | FOR ID IN INTVAL DOT DOT LESS INTVAL GO STMS GC | FOR ID IN ID DOT DOT DOT ID GO STMS GC | FOR ID IN ID DOT DOT LESS ID GO STMS GC | 
FOR ID IN ID DOT DOT DOT INTVAL GO STMS GC | FOR ID IN ID DOT DOT LESS INTVAL GO STMS GC | FOR ID IN INTVAL DOT DOT DOT ID GO STMS GC | FOR ID IN INTVAL DOT DOT LESS ID GO STMS GC | FOR ID IN STRINGVAL GO STMS GC;


COND::= COND:a AND COND:b {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\n%"+(++f.regId)+" = and i1 "+a.getReg()+","+b.getReg());
    int andreg=f.regId;
    f.functionOutput.append("\n%"+(++f.regId)+"=  icmp eq i1 %"+andreg+",1");
    a.setReg(f.regId);
    RESULT=a;
:}| COND:a OR COND:b {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\n%"+(++f.regId)+" = or i1 "+a.getReg()+","+b.getReg());
    int andreg=f.regId;
    f.functionOutput.append("\n%"+(++f.regId)+"= icmp eq i1 %"+andreg+",1");
    a.setReg(f.regId);
    RESULT=a;
:}| NOT COND:a {:
    Function f=functions.get(functionName);
    f.functionOutput.append("\n%"+(++f.regId)+"= icmp eq i1 "+a.getReg()+",0");
    a.setReg(f.regId);
    RESULT=a;
:} | CONDATTR:a {:
    if(!a.type.equals("i1")){
        Function f=functions.get(functionName);
        if(a.type.equals("double"))  f.functionOutput.append("\n%"+(++f.regId)+"= fcmp ne "+a.type+" "+a.getReg()+",0");
        else    f.functionOutput.append("\n%"+(++f.regId)+"= icmp ne "+a.type+" "+a.getReg()+",0");
        RESULT=new Attribute("i1",f.regId);
    }
    else    RESULT=a;
:} | BO COND:a BC {: RESULT=a;
:};

CONDATTR::= EXP:a CONDOP:cond EXP:b {:
    System.out.println("got into ATTR CONDOP ATTR");
    Function f=functions.get(functionName);
    if(!b.type.equals("double"))  f.functionOutput.append("\n%"+(++f.regId)+"= icmp "+getCondIrOp(cond,true)+" "+a.type+" "+a.getReg()+","+b.getReg());
    else f.functionOutput.append("\n%"+(++f.regId)+"= fcmp "+getCondIrOp(cond,false)+" "+a.type+" "+a.getReg()+","+b.getReg());
    System.out.println("Got over condattr reduce with reg:"+f.regId);
    RESULT=new Attribute("i1",f.regId);
:}| EXP:a {:RESULT=a;:};

CONDOP::= LESS {:RESULT=operations.LESS;:} | GREATER {:RESULT=operations.GRT;:} | LESSEQ {:RESULT=operations.LSE;:} | GREATEREQ {:RESULT=operations.GRE;:} | EQUAL {:RESULT=operations.EQ;:};

//function declaration

FUNCTION::=FUNCDef:f GO FSTMTS GC {:
    if(!f.returned){
        if(f.retType.equals("void"))    f.functionOutput.append("\nret void");
        else    System.out.println("Didn't have a return statement and function isn't of type void");
    }
    outputBuffer.append("{\n"+f.functionOutput+"\n}");
    inFunction=false;
    functionName="";
    scopes.remove(scopes.size()-1);
:};

FUNCDef::=FUNC ID:name BO PARlist:l BC RETVAL:r{:
    inFunction=true;
    functionName=name;
    System.out.println("Function "+name+" found!");
    outputBuffer.append("\ndefine "+r+" @"+name+" ("+l.stream().map(e->e.type.irDec()+" %"+e.name).collect(Collectors.joining(","))+")");
    Function f=new Function(name,r,l);
    f.scope=new Scope();
    scopes.add(f.scope);
    functions.put(name,f);
    l.forEach(e->{
        if(!e.inout){
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec());
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.functionOutput.append("\nstore "+e.type.irDec()+" %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            f.scope.constants.put(e.name,v);
        }
        else{
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec()+"*");
            int reg=f.regId;
            f.functionOutput.append("\nstore "+e.type.irDec()+"* %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            f.functionOutput.append("\n%"+(++f.regId)+" = load "+e.type.irDec()+"*,"+e.type.irDec()+"** %"+f.regId);
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.scope.variables.put(e.name,v);
        }
    });
    RESULT=f;
:};

RETVAL::=ARROW T:t {:RESULT=t.irDec();:}| {:RESULT="void";:};

PARlist::= PARlist:l C PAR:p {:
    l.add(p);
    RESULT=l;
:}| PAR:p {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    l.add(p);
    RESULT=l;
:} | {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    RESULT=l;
:};

PAR::= ID:label ID:name FTYPE:f {:RESULT=new Parameter(f.inout,name,f.value,label);:}| ID:name FTYPE:f {:RESULT=new Parameter(f.inout,name,f.value,name);:}| USCORE ID:name FTYPE:f{:RESULT=new Parameter(f.inout,name,f.value);:};
 
FTYPE::= COL INOUTF:i TList:t {:RESULT=new FValue(i,t);:}| COL INOUTF:i TList:t EQ VAL{:RESULT=new FValue(i,t);:};

INOUTF::=INOUT {:RESULT=true;:} | {:RESULT=false;:};

FSTMTS::= FSTMTS STM | STM;

RET::= RETURN EXP:e {:
    Function f=functions.get(functionName);
    if(f.retType.equals(e.type)){
        f.functionOutput.append("\nret "+e.type+" "+e.getReg());
        f.returned=true;
    }
    else System.out.println("Returning a type that doesn't match with the return type of the function");
:} | RETURN {:
    Function f=functions.get(functionName);
    if(!f.retType.equals("void")) System.out.println("REturning nothing from a non void function");
    else{
        f.functionOutput.append("\nret void");
        f.returned=true;
    }
:};

//Class parser

CLASSDEF::= CLASS ID GO CSTMTS GC;

CSTMTS::= CSTMTS STM {: System.out.println("\tPARSER:: Found new class statement"); :}| STM {: System.out.println("\tPARSER:: Found new class statement"); :};
