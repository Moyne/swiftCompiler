import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Object;
import java.util.stream.Collectors ;
import java.lang.Math.*;

parser code {:
    public enum operations{
        ADD,
        MUL,
        DIV,
        SUB,
        LESS,
        GRT,
        LSE,
        GRE,
        EQ
    };
    public class Scope{
        public HashMap<String,Value> variables;
        public HashMap<String,Value> constants;
        public Scope(){
            this.variables=new HashMap<String,Value>();
            this.constants=new HashMap<String,Value>();
        }
    }
    public class Parameter{
        public boolean argLabel;
        public String name;
        public String label;
        public Value type;
        public boolean arrDim=false;
        public Parameter(Value type,String name){
            this.argLabel=false;
            this.name=name;
            this.type=type;
        }
        public Parameter(Value type,String name,String label){
            this.argLabel=true;
            this.name=name;
            this.type=type;
            this.label=label;
        }
        public void setArrayDim(){
            this.arrDim=true;
        }
    }
    public class ClassType{
        public int variableIndex;
        public HashMap<String,Function> functions;
        public StringBuffer constructor;
        public Scope scope;
        public String name;
        public StringBuffer typeDef;
        public int constructorReg;
        public ClassType(String name){
            this.name=name;
            this.scope=new Scope();
            this.variableIndex=0;
            this.constructor=new StringBuffer();
            this.functions=new HashMap<String,Function>();
            this.constructor.append("define void @"+name+".default.constructor(%"+name+"* %self){");
            this.typeDef=new StringBuffer();
            this.constructorReg=0;
        }
        public String irDec(){
            return "%"+name;
        }
    }
    public class Function{
        public String name;
        public String retType;
        public ArrayList<Parameter> pars;
        public StringBuffer functionOutput=new StringBuffer();
        public Scope scope;
        public int regId=0;
        public boolean returned;
        public int arrayNum=0;
        public Function(String name,String retType,ArrayList<Parameter> pars){
            this.name=name;
            this.retType=retType;
            this.pars=pars;
            this.returned=false;
        }
        public Function(String name){
            this.name=name;
        }
        public void setPars(ArrayList<Parameter> pars){
            this.pars=pars;
        }
        public void setRet(String retType){
            this.retType=retType;
        }
        public String irDec(){
            return retType+" ("+pars.stream().map(e->e.type.irDec()).collect(Collectors.joining(","))+") @"+name;
        }
    }
    public class Attribute{
        public String type;
        public int regId;
        public boolean immediate;
        public Object immediateValue;
        public boolean arrFunc=false;
        public boolean arrVar=false;
        public String associatedVarName;
        public ArrayList<String> dimensions;
        public ArrayList<Integer> dimensionsInt;
        public Attribute(String type){
            this.type=type;
            this.immediate=false;
        }
        public Attribute(String type,int regId){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
        }
        public Attribute(Object immediateValue,String type){
            this.immediate=true;
            this.immediateValue=immediateValue;
            this.type=type;
        }
        public Attribute(String type,int regId,String associatedVarName){
            this.immediate=false;
            this.type=type;
            this.regId=regId;
            this.associatedVarName=associatedVarName;
        }
        public Attribute(String type,String associatedVarName,int regId,ArrayList<String> dimensions){
            this.type=type;
            this.arrFunc=true;
            this.arrVar=true;
            this.associatedVarName=associatedVarName;
            this.dimensions=dimensions;
            this.regId=regId;
        }
        public Attribute(String type,String associatedVarName,ArrayList<Integer> dimensionsInt,int regId){
            this.type=type;
            this.arrVar=true;
            this.associatedVarName=associatedVarName;
            this.dimensionsInt=dimensionsInt;
            this.regId=regId;
        }
        public void setReg(int regId){
            this.regId=regId;
        }
        public String getReg(){
            if(this.immediate) return this.immediateValue.toString();
            else    return "%"+this.regId;
        }
    }
    public class ArrayDec{
        public String type;
        public ArrayList<Attribute> value;
        public ArrayList<ArrayDec> arraysInside;
        public boolean closed;
        public boolean last;
        public boolean allImmediates;
        public ArrayDec(String type,ArrayList<Attribute> value,boolean closed,boolean allImmediates){
            this.type=type;
            this.value=value;
            this.closed=closed;
            this.last=true;
            this.allImmediates=allImmediates;
        }
        public ArrayDec(ArrayList<ArrayDec> arraysInside,String type,boolean closed,boolean allImmediates){
            this.type=type;
            this.arraysInside=arraysInside;
            this.closed=closed;
            this.last=false;
            this.allImmediates=allImmediates;
        }
        public void close(){
            this.type="["+arraysInside.size()+" x "+this.type+"]";
            this.closed=true;
        }
        public int level(){
            if(this.last) return 1;
            else return this.arraysInside.get(0).level();
        }
        public String printValue(){
            StringBuffer res=new StringBuffer();
            res.append("[");
            if(this.last){
                for(int i=0;i<value.size();i++){
                    res.append(value.get(i).immediateValue);
                    if(i!=value.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
            else{
                for(int i=0;i<arraysInside.size();i++){
                    res.append(arraysInside.get(i).printValue());
                    if(i!=arraysInside.size()-1) res.append(",");
                }
                res.append("]");
                return res.toString();
            }
        }
        public ArrayList<Integer> getDimensions(){
            ArrayList<Integer> dims=new ArrayList<Integer>();
            if(this.last){
                dims.add(value.size());
                return dims;
            }
            else{
                dims.add(arraysInside.size());
                arraysInside.get(0).getDimensions().forEach(e->dims.add(e));
                return dims;
            }
        }
    }
    public class Value{
        public boolean integer=false;
        public boolean str=false;
        public boolean array=false;
        public boolean doub=false;
        public boolean classRef=false;
        public boolean inClass=false;
        public boolean funcPar=false;
        public boolean initialized;
        public boolean primitive;
        public boolean inoutPar=false;
        public int sizeInt=0;
        public int indexClass;
        public ClassType classType;
        public int pointerAllocated=(-1);
        public boolean global=false;
        public String name;
        public ArrayList<String> dimensionsParameters=new ArrayList<String>();
        public ArrayList<Integer> dimensions=new ArrayList<Integer>();
        public Object immediateInitialization;
        //copy of already existing value
        public Value(Value o){
            this.integer=o.integer;
            this.str=o.str;
            this.doub=o.doub;
            this.array=o.array;
            this.classRef=o.classRef;
            this.sizeInt=o.sizeInt;
            this.classType=o.classType;
            this.inClass=o.inClass;
            this.funcPar=o.funcPar;
            this.initialized=o.initialized;
            this.primitive=o.primitive;
            this.inoutPar=o.inoutPar;
            this.indexClass=o.indexClass;
            this.dimensionsParameters=o.dimensionsParameters;
            this.dimensions=o.dimensions;
            this.immediateInitialization=o.immediateInitialization;
            this.pointerAllocated=o.pointerAllocated;
            this.global=o.global;
        }
        public Value(String type){
            if(type.equals("i32")){
                this.integer=true;
                this.sizeInt=32;
                this.primitive=true;
            }
            else if(type.equals("double")){
                this.doub=true;
                this.primitive=true;
            }
            else if(type.equals("i8*")){
                this.str=true;
                this.primitive=false;
            }
        }
        public Value(int intSize){
            this.integer=true;
            this.sizeInt=intSize;
            this.primitive=true;
        }
        public Value(boolean str){
            this.str=str;
            this.primitive=!str;
            this.doub=!str;
        }
        public Value(ClassType obj){
            this.classType=obj;
            this.classRef=true;
            this.primitive=false;
        }
        public void setImmediateInit(Object obj){
            this.initialized=true;
            this.immediateInitialization=obj;
        }
        public void setArrDimensions(ArrayList<Integer> arr){
            this.dimensions=arr;
        }
        public void setInout(boolean inout){
            this.funcPar=true;
            this.inoutPar=inout;
        }
        public void setClassProperty(int index){
            this.inClass=true;
            this.indexClass=index;
        }
        public void addArrLevel(){
            if(!this.array){
                this.array=true;
                this.dimensions=new ArrayList<Integer>();
                this.dimensions.add(10);
            }
            else this.dimensions.add(10);
        }
        public void addFunctionDimension(String x){
            this.dimensionsParameters.add(x);
        }
        public boolean equal(Value o){
            return this.irDec().equals(o.irDec());
        }
        public String getBaseType(){
            if(this.str) return "i8*";
            else if(this.integer) return "i"+this.sizeInt;
            else if(this.doub) return "double";
            else if(this.classRef) return this.classType.irDec();
            else return "ERROR";
        }
        public void setReg(int regId){
            if(this.pointerAllocated==-1) this.pointerAllocated=regId; 
        }
        public void setReg(String name){
            this.global=true;
            this.name=name;
        }
        public String getReg(){
            if(this.global) return "@"+this.name;
            else return "%"+this.pointerAllocated;
        }
        public String irDec(){
            if(this.array){
                if(this.funcPar)    return this.getBaseType()+"*";
                else{
                    StringBuffer res=new StringBuffer();
                    for(int i=0;i<this.dimensions.size();i++){
                        res.append("["+this.dimensions.get(i)+" x ");
                        if(i==this.dimensions.size()-1){
                            res.append(this.getBaseType());
                            for(int j=0;j<=i;j++) res.append("]");
                        }
                    }
                    return res.toString();
                }
            }
            else{
                if(this.funcPar && this.inoutPar && !this.str) return this.getBaseType()+"*";
                else return this.getBaseType();
            }
        }
        public boolean inoutNeedsDeref(){
            return this.funcPar && this.inoutPar && this.primitive;
        }

        @Override
        public String toString() {
            return this.irDec() +" with reg:"+this.getReg();
        }
    }
    public Scope globalScope=new Scope();
    public ArrayList<Scope> scopes=new ArrayList<Scope>();
    public StringBuffer outputBuffer=new StringBuffer();
    public StringBuffer errorBuffer=new StringBuffer();
    public StringBuffer globalBuffer=new StringBuffer();
    public boolean errors=false;
    public HashMap<String,ClassType> classes=new HashMap<String,ClassType>();
    public HashMap<String,Function> functions=new HashMap<String,Function>();
    public int regid=0;
    public int stringIndex=(-1);
    public boolean inFunction=false;
    public String functionName;
    public int currentIf=0;
    public int currentFor=0;
    public boolean inConditional=false;
    public boolean inClass=false;
    public String className;
    public ArrayList<String> callingFunction=new ArrayList<String>();
    public ArrayList<Integer> callingFunctionPar=new ArrayList<Integer>();
    public ArrayList<Integer> forloops=new ArrayList<Integer>();
    public void append(String x){
        if(inFunction){
            if(inClass) classes.get(className).functions.get(functionName).functionOutput.append(x);
            else    functions.get(functionName).functionOutput.append(x);
        }
        else    errorBuffer.append("\nCannot execute instructions outside of a function");
    }
    public int getId(){
        if(inFunction){
            if(inClass) return ++classes.get(className).functions.get(functionName).regId;
            else    return ++functions.get(functionName).regId;
        }
        else return -1;
    }
    public int getCurrentId(){
        if(inFunction){
            if(inClass) return classes.get(className).functions.get(functionName).regId;
            else    return functions.get(functionName).regId;
        }
        else return -1;
    }
    public String getIrOp(operations op,String type){
        boolean integer=type.equals("i32");
        System.out.println("Inside getirop with type: "+type+" and operator : "+op+", is it integer? "+integer);
        if(op==operations.ADD){
            if(integer) return "add nsw";
            else return "fadd nsw";
        }
        else if(op==operations.SUB){
            if(integer) return "sub";
            else return "fsub";
        }
        else if(op==operations.MUL){
            if(integer) return "mul";
            else return "fmul";
        }
        else if(op==operations.DIV){
            if(integer) return "sdiv";
            else return "fdiv";
        }
        else return "NOT SUPPORTED";
    }
    public String getVarIrDec(String var){
        System.out.println("Inside getvarirdec with: "+var+" and infunction? "+inFunction);
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)) return scope.variables.get(var).irDec();
            else if(scope.constants.containsKey(var)) return scope.constants.get(var).irDec();
        }
        return "ERROR";
    }
    public Value getValue(String var){
        System.out.println("Inside getvalueee with: "+var+" and infunction? "+inFunction);
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)){
                System.out.println("FOund the variale in the "+i+" scope as a var");
                return scope.variables.get(var);
            }
            else if(scope.constants.containsKey(var)){
                System.out.println("FOund the variale in the "+i+" scope as a let");
                return scope.constants.get(var);
            }
        }
        System.out.println("\tError couldn't find the variable "+var+", right now scope has size:"+scopes.size()+"and here are they now:");
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            System.out.println("vars:"+scope.variables);
            System.out.println("lets:"+scope.constants);
        }
        return null;
    }
    public String getRegVar(String var){
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            if(scope.variables.containsKey(var)) return scope.variables.get(var).getReg();
            else if(scope.constants.containsKey(var)) return scope.constants.get(var).getReg();
        }
        System.out.println("\tError couldn't find the variable "+var+", right now scope has size:"+scopes.size()+"and here are they now:");
        for(int i=scopes.size()-1;i>=0;i--){
            Scope scope=scopes.get(i);
            System.out.println("vars:"+scope.variables);
            System.out.println("lets:"+scope.constants);
        }
        return "ERROR";
    }
    public void storeRow(int i,ArrayDec a){
        Function f=functions.get(functionName);
        if(a.last){
            for(int j=0;j<a.value.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                f.functionOutput.append("\nstore "+a.value.get(j).type+" "+a.value.get(j).getReg()+","+a.value.get(j).type+"* %"+f.regId);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                f.functionOutput.append("\n%"+(++f.regId)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                storeRow(f.regId,a.arraysInside.get(j));
            }
        }
    }
    public void storeConstrClassRow(int i,ArrayDec a){
        ClassType ct=classes.get(className);
        if(a.last){
            for(int j=0;j<a.value.size();j++){
                ct.constructor.append("\n%"+(++ct.constructorReg)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                ct.constructor.append("\nstore "+a.value.get(j).type+" "+a.value.get(j).getReg()+","+a.value.get(j).type+"* %"+ct.constructorReg);
            }
            return;
        }
        else{
            for(int j=0;j<a.arraysInside.size();j++){
                ct.constructor.append("\n%"+(++ct.constructorReg)+" = getelementptr inbounds "+a.type+","+a.type+"* %"+i+",i32 0,i32 "+j);
                storeConstrClassRow(ct.constructorReg,a.arraysInside.get(j));
            }
        }
    }
    public String getCondIrOp(operations cond,boolean integer){
        if(cond==operations.LESS){
            if(integer) return "slt";
            else return "olt";
        }
        else if(cond==operations.GRT){
            if(integer) return "sgt";
            else return "ogt";
        }
        else if(cond==operations.LSE){
            if(integer) return "sle";
            else return "ole";
        }
        else if(cond==operations.GRE){
            if(integer) return "sge";
            else return "oge";
        }
        else if(cond==operations.EQ){
            if(integer) return "eq";
            else return "oeq";
        }
        else return "ERROR";
    }
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error, BUT BEFORE HERE WAS THE MAIN CONTENT: "+functions.get(functionName).functionOutput.toString()+"\n\n");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
:};

action code{:
    
:};

terminal LET,VAR,DOUBLEVAL,INTVAL;
terminal String ID,STRINGVAL,STRINGVALS,STRINGVALI,STRINGVALE;
terminal C,EQ,COL,BO,BC,GO,GC,ARROW;
terminal STRING,DOUBLE,INT,FUNC,USCORE;
terminal PLUS,MINUS,DIV,MUL;
terminal LESS,GREATER,LESSEQ,GREATEREQ,AND,OR,EQUAL,NOT;
terminal ELIF,ELSE,IF,FOR,IN,WHILE,DOT;
terminal QO,QC,INOUT,CLASS;
terminal PRINT,RETURN;
terminal BREAK,CONTINUE,DEREF;
terminal uminus;

non terminal PROG,DEC,IDINITlist,INIT;
non terminal ASS,STMS,STM,FUNCTION,FSTMTS;
non terminal WHILECOND,FORCOND;
non terminal ATTRL;
non terminal CLASSDEF;
non terminal ArrayList<String> IDlist;
non terminal Value TYPE;
non terminal Attribute VAL;
non terminal Value TList,T;
non terminal operations OP;
non terminal Attribute ATTR,EXP,PROC;
non terminal Parameter PAR,CLABEL;
non terminal ArrayList<Parameter> PARlist;
non terminal Attribute CPAR;
non terminal ArrayList<Attribute> CPARlist;
non terminal String RETVAL;
non terminal Value FTYPE;
non terminal Boolean INOUTF;
non terminal Attribute STR;
non terminal Integer STRINGVALINTERP;
non terminal Function FUNCDef;
non terminal ArrayList<Integer> PRINTPARList;
non terminal Attribute  IDARR;
non terminal ArrayDec ARRVALE,ARRVAL;
non terminal ArrayList<Attribute> EXPL;
non terminal Integer IFCONDDEC;
non terminal Attribute IFCC,IFCOND;
non terminal IFCOMPLETEBLOCK;
non terminal Attribute CONDATTR,COND;
non terminal operations CONDOP;
non terminal Integer WHILEDEF;
non terminal RET;

precedence left PLUS,MINUS,OR;
precedence left MUL,DIV,AND;
precedence left uminus;

start with PROG;

PROG::= {:scopes.add(globalScope);:} STMS {:System.out.println("At the end the global buffer has:\n"+globalBuffer+"\nand theoutput buffer has:\n"+outputBuffer+"\n");:};

//declarations of variables

DEC::= LET IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        if(inClass){
            if(t.initialized){
                ClassType ct=classes.get(className);
                ct.constructor.append("\n%"+(++ct.constructorReg)+"= getelementptr inbounds %"+className+",%"+className+"* %self,i32 0,i32 "+ct.variableIndex);
                int id=ct.constructorReg;
                if(t.array){
                    ArrayDec dec=(ArrayDec) t.immediateInitialization;
                    storeConstrClassRow(id,dec);
                }
                else{
                    Attribute att=(Attribute) t.immediateInitialization;
                    ct.constructor.append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
                }
                if(ct.variableIndex==0) ct.typeDef.append(t.irDec());
                else ct.typeDef.append(","+t.irDec());
                Value v=new Value(t);
                v.setClassProperty(ct.variableIndex);
                ct.variableIndex++;
                scopes.get(scopes.size()-1).constants.put(a,v);
            }
            else if(t.classRef){
                ClassType ct=classes.get(className);
                ct.constructor.append("\n%"+(++ct.constructorReg)+"= getelementptr inbounds %"+className+",%"+className+"* %self,i32 0,i32 "+ct.variableIndex);
                ct.constructor.append("\ncall void ("+t.irDec()+"*) @"+t.classType.name+".default.constructor("+t.irDec()+"* %"+ct.constructorReg+")");
                Value v=new Value(t);
                v.setClassProperty(ct.variableIndex);
                ct.variableIndex++;
                scopes.get(scopes.size()-1).constants.put(a,v);
            }
            else{
                errorBuffer.append("\ncannot declare a property of a class and not initialize it directly");
            }
        }
        else{
            if(t.initialized){
                if(t.array){
                    ArrayDec dec=(ArrayDec) t.immediateInitialization;
                    if(dec.allImmediates) globalBuffer.append("\n@"+a+" = global "+dec.type+" "+dec.printValue());
                    else errorBuffer.append("Cannot initialize a global variable that doesn't have static values");
                }
                else{
                    Attribute att=(Attribute) t.immediateInitialization;
                    if(att.immediate)   globalBuffer.append("\n@"+a+"= global "+t.irDec()+" "+att.getReg()+",align 4");
                    else{
                        errorBuffer.append("\ncannot declare and initialize a global variable with a dynamic value");
                    }
                }
            }
            else if(t.classRef){
                errorBuffer.append("\ncannot have a global variable that is an object");
            }
            else globalBuffer.append("\n@"+a+" = global "+t.irDec()+" zeroinitializer");
            Value v=new Value(t);
            v.setReg(a);
            scopes.get(scopes.size()-1).constants.put(a,v);
        }
    }
    else{
        int id=getId();
        append("\n%"+id+"= alloca "+t.irDec()+",align 4");
        if(t.initialized){
            if(t.array){
                int i=getCurrentId();
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                storeRow(i,dec);
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
            }
        }
        else if(t.classRef){
            append("\ncall void ("+t.irDec()+"*) @"+t.classType.name+".default.constructor("+t.irDec()+"* %"+id+")");
        }
        Value v=new Value(t);
        v.setReg(id);
        scopes.get(scopes.size()-1).constants.put(a,v);
    }
});:} | VAR IDlist:l TYPE:t {: 
l.forEach(a->{
    if(!inFunction){
        if(t.initialized){
            if(t.array){
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                if(dec.allImmediates) globalBuffer.append("\n@"+a+" = global "+dec.type+" "+dec.printValue());
                else errorBuffer.append("Cannot initialize a global variable that doesn't have static values");
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                globalBuffer.append("\n@"+a+"= global "+t.irDec()+" "+att.getReg()+",align 4");
            }
        }
        else globalBuffer.append("\n@"+a+" = global "+t.irDec()+" zeroinitializer");
        Value v=new Value(t);
        v.setReg(a);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
    else{
        int id=getId();
        append("\n%"+id+"= alloca "+t.irDec()+",align 4");
        if(t.initialized){
            if(t.array){
                int i=getCurrentId();
                ArrayDec dec=(ArrayDec) t.immediateInitialization;
                storeRow(i,dec);
            }
            else{
                Attribute att=(Attribute) t.immediateInitialization;
                append("\nstore "+t.irDec()+" "+att.getReg()+","+t.irDec()+"* %"+id);
            }
        }
        Value v=new Value(t);
        v.setReg(id);
        scopes.get(scopes.size()-1).variables.put(a,v);
    }
});:} | LET IDINITlist | VAR IDINITlist;

IDlist::= IDlist:l C ID:x {: ArrayList<String> arr= new ArrayList<String>(l);
                            arr.add(x);
                            RESULT=arr;:}| ID:x{:ArrayList<String> arr= new ArrayList<String>();
                            arr.add(x);
                            RESULT=arr;:};

IDINITlist::= IDINITlist C INIT | INIT;

INIT::= ID EQ VAL | ID:i EQ ARRVALE:l {:
    Function f=functions.get(functionName);
    System.out.println("Arrived at def of "+i+" that is arrval with type: "+l.type);
    f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+l.type);
    storeRow(f.regId,l);
    Value v=new Value(l.type);
    v.setReg(f.regId);
    scopes.get(scopes.size()-1).variables.put(i,v);
:} ;

TYPE::= COL TList:t {:RESULT=t;:}| COL TList:t EQ VAL:v {:
    t.setImmediateInit(v);
    RESULT=t;
:} | COL TList:t EQ ARRVALE:l {:
    t.setArrDimensions(l.getDimensions());
    t.setImmediateInit(l);
    RESULT=t;
:};

VAL::= DOUBLEVAL:v {:RESULT=new Attribute(v,"double");:}| INTVAL:v {:RESULT=new Attribute(v,"i32");:}| STR:v {:RESULT=v;:};

STR::= STRINGVAL:s {:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    int id;
    if(inFunction){
        append("\n%"+getId()+" = getelementptr inbounds ["+s.length()+" x i8], ["+s.length()+" x i8]* @.str."+stringIndex+" , i32 0, i32 0");
        RESULT=new Attribute("i8*",getCurrentId());
    }
    else{
        RESULT=new Attribute("getelementptr inbounds (["+s.length()+" x i8], ["+s.length()+" x i8]* @.str."+stringIndex+" , i32 0, i32 0)","["+(s.length()+1)+" x i8]");
    }
:}| STRINGVALS:s STRINGVALINTERP:i STRINGVALE:e{:
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(e.length()+1)+" x i8] c\""+e+"\\00\"");
    int stringArrPointer;
    int stringGepPointer;
    append("\n%"+getId()+" = alloca [200 x i8], align 1");
    stringArrPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [200 x i8], [200 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
    stringGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+(stringIndex-1)+", i32 0, i32 0))");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* %"+i+")");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+stringGepPointer+",i8* getelementptr inbounds(["+(e.length()+1)+" x i8], ["+(e.length()+1)+" x i8]* @.str."+stringIndex+" , i32 0, i32 0))");
    RESULT=new Attribute("i8*",stringGepPointer);
:};

STRINGVALINTERP::= STRINGVALINTERP:i STRINGVALI:s EXP:e {:
    int expPointer,expGep,finalArrPointer,finalGepPointer;
    globalBuffer.append("\n@.str."+(++stringIndex)+" = constant ["+(s.length()+1)+" x i8] c\""+s+"\\00\"");
    append("\n%"+getId()+" = alloca [200 x i8], align 1");
    finalArrPointer=getCurrentId();
    append("\n%"+getId()+" = alloca [20 x i8], align 1");
    expPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+expPointer+" , i32 0, i32 0");
    expGep=getCurrentId();
    append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+expGep+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
    append("\n%"+getId()+" = getelementptr inbounds [200 x i8],[200 x i8]* %"+finalArrPointer+",i32 0,i32 0");
    finalGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+finalGepPointer+",i8* %"+i+")");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+finalGepPointer+",i8* getelementptr inbounds (["+(s.length()+1)+" x i8], ["+(s.length()+1)+" x i8]* @.str."+stringIndex+",i32 0,i32 0))");
    append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+finalGepPointer+",i8* %"+expGep+")");
    RESULT=finalGepPointer;
:}| EXP:e {:
    int stringArrPointer;
    int stringGepPointer;
    append("\n%"+getId()+" = alloca [20 x i8], align 1");
    stringArrPointer=getCurrentId();
    append("\n%"+getId()+" = getelementptr inbounds [20 x i8], [20 x i8]* %"+stringArrPointer+" , i32 0, i32 0");
    stringGepPointer=getCurrentId();
    append("\n%"+getId()+" = call i32 (i8*,i8*, ...) @sprintf(i8* %"+stringGepPointer+",i8* getelementptr inbounds([3 x i8], [3 x i8]* @.str.int, i32 0, i32 0), i32 "+e.getReg()+")");
    RESULT=stringGepPointer;
:};

ARRVALE::= QO ARRVALE:l QC {:
    l.close();
    RESULT=l;
:}| ARRVALE:l C ARRVALE:a {:
    if(l.closed && a.closed){
        ArrayList<ArrayDec> arr=new ArrayList<ArrayDec>();
        arr.add(l);
        arr.add(a);
        RESULT=new ArrayDec(arr,a.type,false,a.allImmediates&&l.allImmediates);
    }
    else{
        a.arraysInside.add(0,l);
        a.allImmediates=a.allImmediates&&l.allImmediates;
        RESULT=a;
    }
:}| ARRVAL:a {:RESULT=a;:};

ARRVAL::= QO EXPL:l QC {:
    boolean allImmediates=true;
    for(int i=0;i<l.size();i++){
        if(!l.get(i).immediate){
            allImmediates=false;
            break;
        }
    }
    RESULT=new ArrayDec("["+l.size()+" x "+l.get(0).type+"]",l,true,allImmediates);
:};

EXPL::= EXPL:l C EXP:e {:
    l.add(e);
    RESULT=l;
:} | EXP:e {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    l.add(e);
    RESULT=l;
:} | ;

TList::= QO TList:t QC {:
    t.addArrLevel();
    RESULT=t;
:}| T:t {:RESULT=t;:};

T::=STRING {:RESULT=new Value(true);:}| DOUBLE {:RESULT=new Value(false);:}| INT{:RESULT=new Value(32);:} | ID:name {:
    boolean cont=false;
    for (String key : classes.keySet()) {
        if (name.contains(key)) {
            cont=true;
            break;
        }
    }
    if(!cont){
        errors=true;
        errorBuffer.append("\nTried to assign a non specified type to a variable");
    }
    else    RESULT=new Value(classes.get(name));
:};

//assignment

ASS::= ID:a EQ EXP:e {:
    String type=getVarIrDec(a);
    if(!e.type.equals(type)){
        System.out.println("\t\t\tERRORRRRR IN ASSINGMENT");
    }
    System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
    append("\nstore "+type+" "+e.getReg()+","+type+"* "+getRegVar(a));
:} | IDARR:a EQ EXP:e {:
    append("\nstore "+e.type+" "+e.getReg()+","+a.type+"* "+a.getReg());
:} | ID:a OP:op EQ EXP:e {:
    String type=getVarIrDec(a);
    if(!e.type.equals(type)){
        System.out.println("\t\t\tERRORRRRR IN ASSINGMENT");
    }
    System.out.println("\n\tInside ASSIGNMENT;  with exp: "+e.type+" and id of type: "+type);
    if(type.equals("i8*")){
        if(op==operations.ADD){
            append("\n%"+getId()+"= alloca [200 x i8]");
            int newArr=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds [200 x i8],[200 x i8]* %"+newArr+",i32 0, i32 0");
            int idPointer=getCurrentId();
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcpy(i8* %"+idPointer+",i8* "+getRegVar(a)+")");
            append("\n%"+getId()+" = call i8* (i8*,i8*) @strcat(i8* %"+idPointer+",i8* "+e.getReg()+")");
            append("\nstore i8* %"+idPointer+",i8** "+getRegVar(a));
        }
        else errorBuffer.append("\nonly operation allowed on string is the add");
    }
    else{
        //String type=getVarIrDec(a);
        int id;
        append("\n%"+getId()+"= load "+type+","+type+"* "+getRegVar(a));
        id=getCurrentId();
        append("\n%"+getId()+" = "+getIrOp(op,e.type)+" "+e.type+" %"+id+","+e.getReg());
        append("\nstore "+e.type+" %"+getCurrentId()+","+e.type+"* "+getRegVar(a));
    }
:};

CPAR::= CLABEL:p EXP:e {:
    if(!p.type.irDec().equals(e.type)){
        errorBuffer.append("Type mismatch in parameter passing");
    }
    RESULT=e;
:} | CLABEL ID:i {:
    Value v=getValue(i);
    if(v.array){
        if(v.funcPar){
            append("\n%"+getId()+" = load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
            RESULT=new Attribute(v.getBaseType(),i,getCurrentId(),v.dimensionsParameters);
        }
        else{
            String type=v.irDec();
            int lastId=-1;
            ArrayList<Integer> subdim=new ArrayList<Integer>();
            for(int j=0;j<v.dimensions.size();j++){
                String newType,subir;
                if(j>0){
                    append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* %"+lastId+",i32 0,i32 0");
                    subir=type.substring(1,type.length()-1);
                    if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                    else newType=subir.substring(subir.indexOf("["),subir.length());
                    type=newType;
                    lastId=getCurrentId();
                }
                else{
                    append("\n%"+getId()+" = getelementptr inbounds "+type+","+type+"* "+v.getReg()+",i32 0,i32 0");
                    subir=type.substring(1,type.length()-1);
                    if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
                    else newType=subir.substring(subir.indexOf("["),subir.length());
                    type=newType;
                    lastId=getCurrentId();
                    subdim.add(v.dimensions.get(j));
                }
            }
            if(subdim.size()>0) RESULT=new Attribute(type,i,subdim,lastId);
            else RESULT=new Attribute(type,lastId,i);
        }
    }
    else if(v.str){
        append("\n%"+getId()+"= getelementptr "+v.irDec()+","+v.irDec()+"* "+v.getReg()+",i32 0,i32 0");
        RESULT=new Attribute(v.irDec(),getCurrentId(),i);
    }
    else{
        append("\n%"+getId()+"= load "+v.irDec()+","+v.irDec()+"* "+v.getReg());
        RESULT=new Attribute(v.irDec(),getCurrentId(),i);
    }
:} | CLABEL IDARR:i | CLABEL:p DEREF ID:i | CLABEL:p DEREF IDARR:i ;

CLABEL::= ID:name COL {:
    Parameter p=functions.get(callingFunction.get(callingFunction.size()-1)).pars.get(callingFunctionPar.size()-1);
    if(p.argLabel){
        if(!p.label.equals(name)){
            errorBuffer.append("Expected "+p.label+" as the label for the parameter instead received "+name);
        }
    }
    else{
        errorBuffer.append("Didn't expect a label for the parameter instead received "+name);
    }
    RESULT=p;
:} | {:
    Parameter p=functions.get(callingFunction.get(callingFunction.size()-1)).pars.get(callingFunctionPar.size()-1);
    if(p.argLabel){
        errorBuffer.append("Expected "+p.label+" as the label for the parameter instead the label is missing");
    }
    RESULT=p;
:} ;

EXP::= EXP:e PLUS EXP:a {:
    int id;
    if(e.immediate){
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
    }
    else{
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.ADD,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
    }
    id=getCurrentId();
    RESULT=new Attribute(e.type,id);
:}| ATTR:a {:
    RESULT=a;
:}| EXP:e MINUS EXP:a {:
    int id;
    if(e.immediate){
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
    }
    else{
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.SUB,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
    }
    id=getCurrentId();
    RESULT=new Attribute(e.type,id);
:} | EXP:e MUL EXP:a {:
    int id;
    if(e.immediate){
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
    }
    else{
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.MUL,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
    }
    id=getCurrentId();
    RESULT=new Attribute(e.type,id);
:} | EXP:e DIV EXP:a {:
    int id;
    if(e.immediate){
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.immediateValue+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.immediateValue+","+a.getReg());
    }
    else{
        if(a.immediate) append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.getReg()+","+a.immediateValue);
        else append("\n%"+getId()+"= "+getIrOp(operations.DIV,e.type)+" "+e.type+" "+e.getReg()+","+a.getReg());
    }
    id=getCurrentId();
    RESULT=new Attribute(e.type,id);
:} | BO EXP:e BC {:RESULT=e;:}
| MINUS EXP:e {:
    append("\n%"+getId()+" = sub "+e.type+" 0,"+e.getReg());
    RESULT=new Attribute(e.type,getCurrentId());
:} %prec uminus;


ATTR::= PROC:p {:
    RESULT=p;
:} | ID:i {:
    Value v=getValue(i);
    String type=v.irDec();
    String reg=v.getReg();
    int id;
    if(v.inClass){
        append("\n%"+getId()+"= getelementptr inbounds %"+className+",%"+className+"* %self,i32 0,i32 "+v.indexClass);
        reg="%"+getCurrentId();
    }
    append("\n%"+getId()+"= load "+type+","+type+"* "+reg);
    id=getCurrentId();
    RESULT=new Attribute(type,id);
:} | VAL:v {:
    RESULT=v;
:} | IDARR:i {:
    int id;
    append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+i.getReg());
    id=getCurrentId();
    RESULT=new Attribute(i.type,id);
:} ;

IDARR::= IDARR:i QO EXP:a QC {:
    if(i.arrFunc){
        if(i.dimensions.size()>1){
            ArrayList<String> s=new ArrayList<String>();
            for(int j=0;j<i.dimensions.size();j++){
                if(j==0)    append("\n%"+getId()+"= mul i32 %"+i.dimensions.get(j)+","+a.getReg());
                else{
                    int oldId=getCurrentId();
                    append("\n%"+getId()+"= mul i32 %"+oldId+",%"+i.dimensions.get(j));
                    s.add(i.dimensions.get(j));
                }
            }
            int lastId=getCurrentId();
            append("\n%"+getId()+"= add nsw i32 %"+lastId+","+i.getReg());
            RESULT=new Attribute(i.type,i.associatedVarName,getCurrentId(),s);
        }
        else{
            append("\n%"+getId()+"= add nsw i32 "+a.getReg()+","+i.getReg());
            int lastId=getCurrentId();
            Value v=getValue(i.associatedVarName);
            String baseType=v.getBaseType();
            append("\n%"+getId()+"= load "+i.type+","+i.type+"* "+v.getReg());
            int loadId=getCurrentId();
            append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+i.type+" %"+loadId+", i32 %"+lastId);
            RESULT=new Attribute(baseType,getCurrentId(),i.associatedVarName);
        }
    }
    else{
        String ir=i.type;
        append("\n%"+getId()+" = getelementptr inbounds "+i.type+","+i.type+"* "+i.getReg()+", i32 0, i32 "+a.getReg());
        String subir=ir.substring(1,ir.length()-1);
        String newType;
        if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
        else newType=subir.substring(subir.indexOf("["),subir.length());
        RESULT=new Attribute(newType,getCurrentId(),i.associatedVarName);
    }
:} | ID:i QO EXP:a QC {:
    Value v=getValue(i);
    if(v.funcPar && v.dimensions.size()>1){
        System.out.println("Entered the if");
        System.out.println("THere are "+v.dimensions+" AND "+v.dimensionsParameters);
        ArrayList<String> s=new ArrayList<String>();
        for(int j=0;j<v.dimensionsParameters.size();j++){
            if(j==0)    append("\n%"+getId()+"= mul i32 %"+v.dimensionsParameters.get(j)+","+a.getReg());
            else{
                int oldId=getCurrentId();
                append("\n%"+getId()+"= mul i32 %"+oldId+",%"+v.dimensionsParameters.get(j));
                s.add(v.dimensionsParameters.get(j));
            }
        }
        System.out.println("JUst finished the first loop, now dimensions are "+s);
        RESULT=new Attribute(v.irDec(),i,getCurrentId(),s);
    }
    else if(v.funcPar && v.dimensions.size()==1){
        String baseType=v.getBaseType();
        append("\n%"+getId()+"= load "+baseType+"*,"+baseType+"** "+v.getReg());
        int loadId=getCurrentId();
        append("\n%"+getId()+"= getelementptr inbounds "+baseType+","+baseType+"* %"+loadId+", i32 "+a.getReg());
        RESULT=new Attribute(baseType,getCurrentId(),i);
    }
    else{
        String ir=getVarIrDec(i);
        String reg=getRegVar(i);
        append("\n%"+getId()+" = getelementptr inbounds "+ir+","+ir+"* "+reg+", i32 0, i32 "+a.getReg());
        String subir=ir.substring(1,ir.length()-1);
        String newType;
        if(subir.indexOf("[")<0)    newType=subir.substring(subir.indexOf("x")+2,subir.length());
        else newType=subir.substring(subir.indexOf("["),subir.length());
        RESULT=new Attribute(newType,getCurrentId(),i);
    }
:} ;

OP::= PLUS {:RESULT=operations.ADD;:} | MINUS {:RESULT=operations.SUB;:} | MUL {:RESULT=operations.MUL;:} | DIV {:RESULT=operations.DIV;:} ;

//statements

STMS::= STMS STM | STM;

STM::=ASS | PROC | DEC | FUNCTION | IFCOMPLETEBLOCK | WHILECOND | FORCOND | CLASSDEF | RET
| BREAK {:
    if(inConditional){
        append("\nbr label %for.exit."+forloops.get(forloops.size()-1));
        getId();
    }
    else {
        errorBuffer.append("Used continue statement while not in a for loop or while loop");
    }
:} | CONTINUE {:
    if(inConditional){
        append("\nbr label %for.inc."+forloops.get(forloops.size()-1));
        getId();
    }
    else {
        errorBuffer.append("Used continue statement while not in a for loop or while loop");
    }
:};

PROC::= ID:name {:
    callingFunction.add(name);
    callingFunctionPar.add(0);
:} BO CPARlist:l BC {:
    Function f=functions.get(name);
    int id=0;
    if(f.retType.equals("void"))    append("\ncall "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
    else{
        append("\n%"+(getId())+"=call "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+")");
        id=getCurrentId();
    }
    callingFunctionPar.remove(callingFunctionPar.size()-1);
    callingFunction.remove(callingFunction.size()-1);
    RESULT=new Attribute(f.retType,id);
:} | PRINT BO PRINTPARList:l BC{:
        l.forEach(p->append("\n%"+getId()+" = call i32 (i8*, ...) @printf(i8* %"+p+")"));
        append("\n%"+getId()+" = call i32 (i8*, ...) @printf(i8* getelementptr inbounds([2 x i8], [2 x i8]* @.str.newline, i32 0, i32 0))");
:} | ID:a DOT ID:cproc {:
    Value v=getValue(a);
    if(v.classType.functions.containsKey(cproc)){
        callingFunction.add(cproc);
        callingFunctionPar.add(0);
    }
    System.out.println("\tStartring to read function call that is part of class");
:} BO CPARlist:l BC {:
    Value v=getValue(a);
    Function f=v.classType.functions.get(cproc);
    int id=0;
    if(f.retType.equals("void"))    append("\ncall "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+","+v.irDec()+" "+v.getReg()+")");
    else{
        append("\n%"+(getId())+"=call "+f.irDec()+"("+l.stream().map(e->e.type+" "+e.getReg()).collect(Collectors.joining(","))+","+v.irDec()+" "+v.getReg()+")");
        id=getCurrentId();
    }
    callingFunctionPar.remove(callingFunctionPar.size()-1);
    callingFunction.remove(callingFunction.size()-1);
    RESULT=new Attribute(f.retType,id);
:};

PRINTPARList::= PRINTPARList:l C STR:s {:
    l.add(s.regId);
    RESULT=l;
:}| STR:s{:
    ArrayList<Integer> pointers=new ArrayList<Integer>();
    pointers.add(s.regId);
    RESULT=pointers;
:};

CPARlist::= CPARlist:l C CPAR:p {:
    System.out.println("REduced cparlist c cpar in cparlist");
    l.add(p);
    if(p.arrVar){
        if(p.arrFunc){
            for(int i=0;i<p.dimensions.size();i++){
                append("\n%"+getId()+"= load i32,i32* "+p.dimensions.get(i));
                l.add(new Attribute("i32",getCurrentId()));
            }
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensions.size());
        }
        else{
            for(int i=0;i<p.dimensionsInt.size();i++)  l.add(new Attribute(p.dimensionsInt.get(i),"i32"));
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensionsInt.size());
        }
    }
    RESULT=l;
:} | {:
    ArrayList<Attribute> l=new ArrayList<Attribute>();
    System.out.println("REduced EMPTY in cparlist");
    RESULT=l;
:} | CPAR:p{:
ArrayList<Attribute> l=new ArrayList<Attribute>();
    System.out.println("REduced cpar in cparlist");
    l.add(p);
    if(p.arrVar){
        if(p.arrFunc){
            for(int i=0;i<p.dimensions.size();i++){
                append("\n%"+getId()+"= load i32,i32* "+p.dimensions.get(i));
                l.add(new Attribute("i32",getCurrentId()));
            }
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensions.size());
        }
        else{
            for(int i=0;i<p.dimensionsInt.size();i++)  l.add(new Attribute(p.dimensionsInt.get(i),"i32"));
            callingFunctionPar.set(callingFunctionPar.size()-1,callingFunctionPar.get(callingFunctionPar.size()-1)+p.dimensionsInt.size());
        }
    }
    RESULT=l;
:};


//control loop blocks

IFCOMPLETEBLOCK::= IFCC:ifc {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    append("\nbr label %if.exit."+ifc.type+".0");
    append("\nif.exit."+ifc.type+".0:");
:} | IFCC:ifc ELSE {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO STMS GC {:
    append("\nbr label %if.exit."+ifc.type+".0");
    append("\nif.exit."+ifc.type+".0:");
    scopes.remove(scopes.size()-1);
:};

IFCC::= IFCC:ifc ELIF {:
    append("\nif.elif."+ifc.type+"."+ifc.regId+":");
:} COND:cond {:
    append("\nbr i1 "+cond.getReg()+", label %if.body."+ifc.type+"."+ifc.regId+", label %if.elif."+ifc.type+"."+(ifc.regId+1));
    append("\nif.body."+ifc.type+"."+ifc.regId+":");
    scopes.add(new Scope());
:} GO STMS GC {:
    append("\nbr label %if.exit."+ifc.type+".0");
    ifc.setReg(ifc.regId+1);
    scopes.remove(scopes.size()-1);
    RESULT=ifc;
:} | IFCOND:ifc {:RESULT=ifc;:};

IFCOND::= IFCONDDEC:ifNum GO STMS GC {:
    append("\nbr label %if.exit."+ifNum+".0");
    scopes.remove(scopes.size()-1);
    RESULT=new Attribute(""+ifNum,0);
:} | IFCONDDEC STM ;

IFCONDDEC::= IF COND:cond {:
    int currIf=currentIf++;
    append("\nbr i1 "+cond.getReg()+", label %if.body."+currIf+", label %if.elif."+currIf+".0");
    append("\nif.body."+currIf+":");
    scopes.add(new Scope());
    RESULT=currIf;
:};


WHILECOND::= WHILEDEF:wh COND:cond {:
    append("\nbr i1 "+cond.getReg()+", label %for.body."+wh+", label %for.exit."+wh);
    append("\nfor.body."+wh+":");
    scopes.add(new Scope());
    if(!inConditional)  inConditional=true;
    forloops.add(wh);
:} GO STMS GC {:
    append("\nbr label %for.inc."+wh);
    append("\nfor.inc."+wh+":");
    append("\n%"+getId()+" = add nsw i32 0,0");
    append("\nbr label %for.cond."+wh);
    append("\nfor.exit."+wh+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:};

WHILEDEF::= WHILE {:
    int currWh=currentFor++;
    append("\nbr label %for.cond."+currWh);
    append("\nfor.cond."+currWh+":");
    RESULT=currWh;
:};

FORCOND::= FOR ID:index IN INTVAL:start DOT DOT DOT INTVAL:finish {:
    System.out.println("BEfore this for the size of the scope array was : " +scopes.size());
    scopes.add(new Scope());
    System.out.println("AFter it's "+scopes.size());
    int currFor=currentFor++;
    append("\nbr label %for.init."+currFor);
    append("\nfor.init."+currFor+":");
    append("\n%"+getId()+" = alloca i32, align 4");
    int indexId=getCurrentId();
    Value v=new Value(32);
    v.setReg(indexId);
    scopes.get(scopes.size()-1).constants.put(index,v);
    append("\nstore i32 "+start+",i32* %"+indexId);
    append("\nbr label %for.cond."+currFor);
    append("\nfor.cond."+currFor+":");
    append("\n%"+getId()+" = load i32,i32* %"+indexId);
    int idload=getCurrentId();
    append("\n%"+getId()+" = icmp sle i32 %"+idload+","+finish);
    append("\nbr i1 %"+getCurrentId()+", label %for.body."+currFor+", label %for.exit."+currFor);
    append("\nfor.body."+currFor+":");
    if(!inConditional)  inConditional=true;
    forloops.add(currFor);
    RESULT=currFor;
:} GO STMS GC {:
    System.out.println("FInished the for loop, now scopes has size "+scopes.size());
    append("\nbr label %for.inc."+RESULT);
    append("\nfor.inc."+RESULT+":");
    append("\n%"+getId()+" = load i32,i32* "+getRegVar(index));
    int k=getCurrentId();
    append("\n%"+getId()+" = add nsw i32 %"+k+",1");
    append("\nstore i32 %"+getCurrentId()+",i32* "+getRegVar(index));
    append("\nbr label %for.cond."+RESULT);
    append("\nfor.exit."+RESULT+":");
    scopes.remove(scopes.size()-1);
    if(forloops.size()==1) inConditional=false;
    forloops.remove(forloops.size()-1);
:} | FOR ID IN INTVAL DOT DOT LESS INTVAL GO STMS GC | FOR ID IN ID DOT DOT DOT ID GO STMS GC | FOR ID IN ID DOT DOT LESS ID GO STMS GC | 
FOR ID IN ID DOT DOT DOT INTVAL GO STMS GC | FOR ID IN ID DOT DOT LESS INTVAL GO STMS GC | FOR ID IN INTVAL DOT DOT DOT ID GO STMS GC | FOR ID IN INTVAL DOT DOT LESS ID GO STMS GC | FOR ID IN STRINGVAL GO STMS GC;


COND::= COND:a AND COND:b {:
    append("\n%"+getId()+" = and i1 "+a.getReg()+","+b.getReg());
    int andreg=getCurrentId();
    append("\n%"+getId()+"=  icmp eq i1 %"+andreg+",1");
    a.setReg(getCurrentId());
    RESULT=a;
:}| COND:a OR COND:b {:
    append("\n%"+getId()+" = or i1 "+a.getReg()+","+b.getReg());
    int andreg=getCurrentId();
    append("\n%"+getId()+"= icmp eq i1 %"+andreg+",1");
    a.setReg(getCurrentId());
    RESULT=a;
:}| NOT COND:a {:
    append("\n%"+getId()+"= icmp eq i1 "+a.getReg()+",0");
    a.setReg(getCurrentId());
    RESULT=a;
:} | CONDATTR:a {:
    if(!a.type.equals("i1")){
        if(a.type.equals("double"))  append("\n%"+getId()+"= fcmp ne "+a.type+" "+a.getReg()+",0");
        else    append("\n%"+getId()+"= icmp ne "+a.type+" "+a.getReg()+",0");
        RESULT=new Attribute("i1",getCurrentId());
    }
    else    RESULT=a;
:} | BO COND:a BC {: RESULT=a;
:};

CONDATTR::= EXP:a CONDOP:cond EXP:b {:
    if(!b.type.equals("double"))  append("\n%"+getId()+"= icmp "+getCondIrOp(cond,true)+" "+a.type+" "+a.getReg()+","+b.getReg());
    else append("\n%"+getId()+"= fcmp "+getCondIrOp(cond,false)+" "+a.type+" "+a.getReg()+","+b.getReg());
    RESULT=new Attribute("i1",getCurrentId());
:}| EXP:a {:RESULT=a;:};

CONDOP::= LESS {:RESULT=operations.LESS;:} | GREATER {:RESULT=operations.GRT;:} | LESSEQ {:RESULT=operations.LSE;:} | GREATEREQ {:RESULT=operations.GRE;:} | EQUAL {:RESULT=operations.EQ;:};

//function declaration

FUNCTION::=FUNCDef:f GO FSTMTS GC {:
    if(!f.returned){
        if(f.retType.equals("void"))    f.functionOutput.append("\nret void");
        else    System.out.println("Didn't have a return statement and function isn't of type void");
    }
    outputBuffer.append("{"+f.functionOutput+"\n}");
    inFunction=false;
    functionName=null;
    scopes.remove(scopes.size()-1);
:};

FUNCDef::=FUNC ID:name {:
    inFunction=true;
    functionName=name;
    System.out.println("Function "+name+" found!");
    Function f=new Function(name);
    if(inClass) classes.get(className).functions.put(name,f);
    functions.put(name,f);
:} BO PARlist:l BC RETVAL:r{:
    Function f;
    String nameFunc;
    if(inClass){
        f=classes.get(className).functions.get(name);
        nameFunc=className+"."+name;
        Value v=new Value(classes.get(className));
        v.setInout(true);
        System.out.println("\tType of self is : " +v.irDec());
        Parameter p=new Parameter(v,"self");
        l.add(p);
    }
    else{
        f=functions.get(name);
        nameFunc=name;
    }
    outputBuffer.append("\ndefine "+r+" @"+nameFunc+" ("+l.stream().map(e->e.type.irDec()+" %"+e.name).collect(Collectors.joining(","))+")");
    f.setPars(l);
    f.setRet(r);
    f.scope=new Scope();
    scopes.add(f.scope);
    l.stream().filter(e->!e.arrDim && !e.name.equals("self")).forEach(e->{
        System.out.println("Starting parameter "+e.name);
        if(!e.type.inoutNeedsDeref()){
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec());
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.functionOutput.append("\nstore "+e.type.irDec()+" %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            if(e.type.inoutPar) f.scope.variables.put(e.name,v);
            else    f.scope.constants.put(e.name,v);
        }
        else{
            f.functionOutput.append("\n%"+(++f.regId)+" = alloca "+e.type.irDec()+"*");
            int reg=f.regId;
            f.functionOutput.append("\nstore "+e.type.irDec()+"* %"+e.name+", "+e.type.irDec()+"* %"+f.regId);
            f.functionOutput.append("\n%"+(++f.regId)+" = load "+e.type.irDec()+"*,"+e.type.irDec()+"** %"+f.regId);
            Value v=new Value(e.type);
            v.setReg(f.regId);
            f.scope.variables.put(e.name,v);
        }
        System.out.println("JUst finished parameter "+e.name+", now output is:\n"+f.functionOutput);
    });
    RESULT=f;
:};

RETVAL::=ARROW T:t {:RESULT=t.irDec();:}| {:RESULT="void";:};

PARlist::= PARlist:l C PAR:p {:
    l.add(p);
    if(p.type.array){
        int dim=p.type.dimensions.size();
        for(int i=0;i<dim-1;i++){
            Value x=new Value(32);
            x.setInout(false);
            Parameter pfor=new Parameter(x,"dim."+functions.get(functionName).arrayNum+"."+i);
            pfor.setArrayDim();
            l.add(pfor);
            p.type.addFunctionDimension("dim."+functions.get(functionName).arrayNum+"."+i);
            System.out.println("NOw dimensions parameters are: "+p.type.dimensionsParameters);
        }
        if(dim>1) functions.get(functionName).arrayNum++;
    }
    RESULT=l;
:}| PAR:p {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    l.add(p);
    if(p.type.array){
        int dim=p.type.dimensions.size();
        System.out.println("Parameter "+p.name+" has "+dim+" dimensions and function has array num:"+ functions.get(functionName).arrayNum);
        for(int i=0;i<dim-1;i++){
            Value x=new Value(32);
            x.setInout(false);
            Parameter pfor=new Parameter(x,"dim."+functions.get(functionName).arrayNum+"."+i);
            pfor.setArrayDim();
            l.add(pfor);
            p.type.addFunctionDimension("dim."+functions.get(functionName).arrayNum+"."+i);
            System.out.println("NOw dimensions parameters are: "+p.type.dimensionsParameters);
        }
        if(dim>1) functions.get(functionName).arrayNum++;
    }
    RESULT=l;
:} | {:
    ArrayList<Parameter> l=new ArrayList<Parameter>();
    RESULT=l;
:};

PAR::= ID:label ID:name FTYPE:f {:RESULT=new Parameter(f,name,label);:}| ID:name FTYPE:f {:RESULT=new Parameter(f,name,name);:}| USCORE ID:name FTYPE:f{:RESULT=new Parameter(f,name);:};
 
FTYPE::= COL INOUTF:i TList:t {:t.setInout(i);RESULT=t;:};

INOUTF::=INOUT {:RESULT=true;:} | {:RESULT=false;:};

FSTMTS::= FSTMTS STM | STM;

RET::= RETURN EXP:e {:
    Function f;
    if(inClass) f=classes.get(className).functions.get(functionName);
    else    f=functions.get(functionName);
    if(f.retType.equals(e.type)){
        f.functionOutput.append("\nret "+e.type+" "+e.getReg());
        f.returned=true;
        getId();
    }
    else System.out.println("Returning a type that doesn't match with the return type of the function");
:} | RETURN {:
    Function f;
    if(inClass) f=classes.get(className).functions.get(functionName);
    else    f=functions.get(functionName);
    if(!f.retType.equals("void")) System.out.println("REturning nothing from a non void function");
    else{
        f.functionOutput.append("\nret void");
        f.returned=true;
        getId();
    }
:};

CLASSDEF::= CLASS ID:name {:
    ClassType ct=new ClassType(name);
    classes.put(name,ct);
    inClass=true;
    className=name;
:} GO STMS GC {:
    ClassType ct=classes.get(name);
    inClass=false;
    className=null;
    globalBuffer.append("\n%"+name+"= type {"+ct.typeDef.toString()+"}");
    outputBuffer.append("\n"+ct.constructor.toString()+"\nret void\n}");
:} ;